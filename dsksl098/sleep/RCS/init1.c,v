head	1.24;
access;
symbols
	DSLEEPv0_98:1.24
	DSLEEPv0_95:1.16
	DSLEEPv0_93:1.15
	DSLEEPv0_92:1.12
	DSLEEPv0_91:1.9
	DSLEEPv0_80:1.5
	DSLEEPv0_70:1.4
	DSLEEPv0_60:1.3;
locks; strict;
comment	@ * @;


1.24
date	2001.02.27.02.24.47;	author vitus;	state Exp;
branches;
next	1.23;

1.23
date	2001.02.16.02.12.36;	author vitus;	state Exp;
branches;
next	1.22;

1.22
date	99.11.29.00.35.12;	author vitus;	state Exp;
branches;
next	1.21;

1.21
date	99.11.28.23.45.30;	author vitus;	state Exp;
branches;
next	1.20;

1.20
date	98.06.29.00.01.25;	author vitus;	state Exp;
branches;
next	1.19;

1.19
date	98.01.29.22.20.09;	author vitus;	state Exp;
branches;
next	1.18;

1.18
date	97.12.05.01.33.40;	author vitus;	state Exp;
branches;
next	1.17;

1.17
date	97.11.23.22.37.50;	author vitus;	state Exp;
branches;
next	1.16;

1.16
date	97.11.22.01.07.47;	author vitus;	state Exp;
branches;
next	1.15;

1.15
date	97.10.26.00.29.18;	author vitus;	state Exp;
branches;
next	1.14;

1.14
date	97.10.24.23.30.58;	author vitus;	state Exp;
branches;
next	1.13;

1.13
date	97.10.11.17.44.11;	author vitus;	state Exp;
branches;
next	1.12;

1.12
date	97.09.03.01.02.23;	author vitus;	state Exp;
branches;
next	1.11;

1.11
date	97.07.21.01.13.38;	author vitus;	state Exp;
branches;
next	1.10;

1.10
date	97.06.18.00.49.45;	author vitus;	state Exp;
branches;
next	1.9;

1.9
date	97.06.03.23.44.11;	author vitus;	state Exp;
branches;
next	1.8;

1.8
date	97.05.11.14.44.12;	author vitus;	state Exp;
branches;
next	1.7;

1.7
date	97.05.07.23.31.37;	author vitus;	state Exp;
branches;
next	1.6;

1.6
date	97.03.03.01.15.02;	author vitus;	state Exp;
branches;
next	1.5;

1.5
date	97.02.06.01.08.59;	author vitus;	state Exp;
branches;
next	1.4;

1.4
date	96.11.04.00.14.57;	author vitus;	state Exp;
branches;
next	1.3;

1.3
date	96.10.24.00.12.25;	author vitus;	state Exp;
branches;
next	1.2;

1.2
date	96.09.30.00.27.21;	author vitus;	state Exp;
branches;
next	1.1;

1.1
date	96.09.27.02.28.09;	author vitus;	state Exp;
branches;
next	;


desc
@Contains initialisation code
@


1.24
log
@- added /APM and /!APM switches
@
text
@/*
 * $Source: r:/source/driver/sleep/RCS/init1.c,v $
 * $Revision: 1.23 $
 * $Date: 2001/02/16 02:12:36 $
 * $Locker: vitus $
 *
 *	First step of initialisation.
 *
 * History: see bottom of file
 * ------------------------------------------------
 * This code is Copyright Vitus Jensen 1996-99,2001
 */
static char const id[]="$Id: init1.c,v 1.23 2001/02/16 02:12:36 vitus Exp vitus $";

#define INCL_DOSERRORS
#define INCL_NOPMAPI
#define INCL_INITRP_ONLY
#include "dsksleep.h"
#include "cmdphdr.h"
#include "dskslpub.h"
#include "proto.h"
#include "extern.h"



/*
 * Macro to allocate data from memory pool
 */
#define GETINITRAM(p,type,size) (p=(type)npInitData,npInitData+=(size))

#define INITMSG		static char _ininit




/* **********************************************************************
 * **** Debugging Data **************************************************
 * ******************************************************************* */
#if defined(DEBUG)
char _inconst	dszRegister[]=		"\r\nRegistering device class";
char _inconst	dszRemoveFilter[]=	"\r\nRemoveFilter";
char _inconst	dszInstFilter[]=	"\r\nInstallFilter %w";
char _inconst	dszInstFilterEnd[]=	"\r\nInstallFilter ends";
char _inconst	dszInstallTimer[]=	"\r\nInstalling timer";
char _inconst	dszInitBase[]=		"\r\nInitBase";
char _inconst	dszScanDevices[]=	"\r\nScanDevices";
char _inconst	dszAddScan[]=		"\r\nLooking for ADDs";
char _inconst	dszAdpScan[]=		"\r\nLooking for Adapters";
char _inconst	dszUnitScan[]=		"\r\nLooking for Units";
char _inconst	dszOldFilter[]=		"\r\nFound other filter for unit";
char _inconst	dszInstalled[]=		"\r\nDriver installed";
char _inconst	dszNotInstalled[]=	"\r\nDriver *NOT* installed";
char _inconst	dszUnitAlloc[]=		"\r\nallocated unit structure: %w";
#endif /* DEBUG */




/* **********************************************************************
 * **** Messages used during initialization *****************************
 * ******************************************************************* */
INITMSG	szNoDriverTab[]="%s: error retrieving driver table";
INITMSG	szNoDevTab[]=	"%s: error retrieving device table from ADD %u";
INITMSG	szNoSCSI[]=	"%s: adapter %u has no SCSI bus (%04x)";
INITMSG	szNo16M[]=	"%s: adapter %u doesn't support memory above 16MB";
INITMSG	szNoScGa[]=	"%s: adapter %u doesn't support HW scatter/gather";
INITMSG	szNoDiskType[]= "%s: adapter %u, unit %u is no disk device";
INITMSG	szRemovable[]=	"%s: adapter %u, unit %u is removable";
INITMSG	szDiskette[]=	"%s: adapter %u, unit %u is diskette drive";
INITMSG	szDefective[]=	"%s: adapter %u, unit %u is defect";
INITMSG	szAllocFailed[]="%s: adapter %u, unit %u allocation failed";
INITMSG	szDeallocFailed[]="%s: adapter %u, unit %u, deallocation failed";
INITMSG	szChangeUInfoFailed[]="%s: adapter %u, unit %u, change unit info failed";
INITMSG	szNoTimer[]=	"%s: couldn't install timer handler";
INITMSG	szRegDevClassFailed[]=	"%s: error registering device class";
INITMSG	szNoDevices[]=	"%s: no devices found";

/* Related to device test */

INITMSG	szTestStart[]=	"%s: adapter %u, unit %u, device test starts...";
INITMSG	szTestComplete[]= "%s: adapter %u, unit %u, device test ended successfully";
INITMSG	szStopFailed[]= "%s: adapter %u, unit %u STOP UNIT failed (%04x)";
INITMSG	szNoStart[]=	"%s: adapter %u, unit %u, cannot issue START UNIT command";
INITMSG	szStartFailed[]="%s: adapter %u, unit %u, START UNIT failed (%04x)";
INITMSG	szStatusblock[]="%s: StatusBlock, Flags %02x, Adapter Error %04x, Target Status %02x";
INITMSG	szAdapterDiag[]="%s: adapter specific info [%s]";
INITMSG	szSensedata[]=	"%s: sense data [%s]";
INITMSG	szHex[]=	"%02x ";

/* Related to command line parsing */

INITMSG	szCmdLineSyntax[]= "%s: syntax error in command line";
INITMSG	szMissingOption[]= "%s: required option missing in command line";
INITMSG	szUnknownOption[]= "%s: unknown command line option";
INITMSG	szCmdLineError[]="%s: command line option error %d";

/* Other */

INITMSG	szFoundDevice[]="Adapter %u, Unit %u installed (%u min)";



/*
 * Very important :-)
 */
INITMSG szProduct[]="SCSI Disk Sleeper";
INITMSG szLogo[]=	"\n\r%s                                            Version %u.%02u\n\r" \
			"Copyright 1996-97 by Vitus Jensen (2:2474/424)               " __DATE__ ;
INITMSG szNoReg[]= "Not registered for commercial use";
INITMSG szReg[]=	"Registered to: %s";

#define REG_MAGIC	0x53A1B7F9
#define REG_KEYLEN	40
#pragma pack(1)
typedef struct {
    ULONG	ulMagic;
    UCHAR	szUser[REG_KEYLEN];
    UCHAR	szRegCode[REG_KEYLEN];
    ULONG	ulSize;
} REGSTRUCT;
#pragma pack()
REGSTRUCT _ininit RegData = {
    REG_MAGIC,
    "\000T3456789012345678901234567890123456789",
    "nfjhfjhfkjshffdsfsfsfjshfkjshfkjsfhsjkf",
    sizeof(REGSTRUCT) };



#pragma pack(1)
typedef struct {
    UCHAR	adpno;				/* MSB set if valid entry */
    UCHAR	unitno;
    USHORT	to;
} TO_OPTION;
#pragma pack(1)
TO_OPTION _ininit	ToOption[MAX_UNITS] = {0};

PRIVATE USHORT _ininit	usSleepSeconds = SLEEP_TIME; /* timeout without /[!]UT */





/*
 * Last element in code segments which remains resident
 */
PRIVATE void NEAR
Code_End(void) {}




char _ininit	achDump[200];
PRIVATE void NEAR
DumpStatusblock(NPSCSI_STATUS_BLOCK statusblock)
{
    /* Status block */

    sprintk(szMsgBuffer, szStatusblock, (PSZ)szDriverName,
	    statusblock->Flags, statusblock->AdapterErrorCode,
	    statusblock->TargetStatus);
    SaveMessage();

    /* Adapter specific info, only if valid */

    if( (statusblock->Flags & STATUS_DIAGINFO_VALID) )
    {
	USHORT	i;

	achDump[0] = '\0';
	for( i = 0; i < 8; ++i )
	    sprintk(&achDump[_fstrlen(achDump)],
		    szHex, statusblock->AdapterDiagInfo[i]);
	sprintk(szMsgBuffer, szAdapterDiag, (PSZ)szDriverName, (PSZ)achDump);
	SaveMessage();
    }

    /* Sense data, only if valid */

    if( (statusblock->Flags & STATUS_SENSEDATA_VALID) )
    {
	USHORT	i;
	PUCHAR	sensedata = (PUCHAR)statusblock->SenseData;

	achDump[0] = '\0';
	for( i = 0; i < statusblock->ReqSenseLen; ++i )
	    sprintk(&achDump[_fstrlen(achDump)], szHex, sensedata[i]);
	sprintk(szMsgBuffer, szSensedata, (PSZ)szDriverName, (PSZ)achDump);
	SaveMessage();
    }
    return;
}




/*# ----------------------------------------------------------------------
 * SendIORBNotify(iorb)
 *
 * PARAMETER
 *	iorb		completed request
 * RETURNS
 *	nothing
 * GLOBAL
 *	none
 * DESPRIPTION
 *	Awakens any process blocking on the passed IORB.  Used
 *	by 'SendIORB'.
 * REMARKS
 */
PRIVATE void FAR _saveregs _loadds _Cdecl
SendIORBNotify(PIORB iorb)
{
    USHORT awoken;

    DevHelp_ProcRun((ULONG)iorb, &awoken);
    return;
}




/*# ----------------------------------------------------------------------
 * SendIORB(iorb,addentry)
 *
 * PARAMETER
 *	iorb		request to execute
 *	addentry	entry point of ADD to call
 * RETURNS
 *	0		OK
 *	/0		error code returned from ADD
 * GLOBAL
 *	(none)
 * DESPRIPTION
 *	Uses 'SendIORBNotify' as notification routine.
 * REMARKS
 *	Need local variable to prevent restoring sp from bp
 *	after ADD call.
 */
#if defined(_MSC_VER)
# pragma optimize("lge",off)
#endif
PRIVATE USHORT NEAR
SendIORB(PIORB iorb,void (FAR _Cdecl * addentry)(PIORB))
{
    USHORT	rc = 0;

    iorb->NotifyAddress = (PVOID)SendIORBNotify; /* quick hack! */
    iorb->RequestControl |= IORB_ASYNC_POST;
    iorb->ErrorCode =	0;
    iorb->Status =	0;

    CallADD(addentry, iorb);

    cli();
    while( !(iorb->Status & IORB_DONE) )
    {
	rc = DevHelp_ProcBlock((ULONG)iorb, (ULONG)-1l, WAIT_IS_INTERRUPTABLE);
	if( rc != 0 )
	    break;				/* was interrupted: abort! */
	cli();
    }
    sti();

    return (rc != 0
	    ? IOERR_CMD_ABORTED : (iorb->Status & IORB_ERROR ? iorb->ErrorCode : 0));
}
#if defined(_MSC_VER)
# pragma optimize("",on)
#endif




/*# ----------------------------------------------------------------------
 * TestOperation(device)
 *
 * PARAMETER
 *	device		device to test
 * RETURNS
 *	0		OK, test passed
 *	/0		fatal error
 * GLOBAL
 *	none
 * DESPRIPTION
 *	Special setting allows to start/stop unit during startup.
 *	Slow but safe.
 * REMARKS
 *	Last step should be a real READ (ADAPTER_PASSTHRU or EXECUTE_IO),
 *	to skip the generation of a scatter/gather list (not impossible!)
 *	we do a READ_VERIFY.  Hopefully this affects the medium, too.
 */
PRIVATE int NEAR
TestOperation(NPDEVICE const device)
{
    int	flag;

    sprintk(szMsgBuffer, szTestStart, (PSZ)szDriverName,
	    device->iAdapter, device->iUnit);
    SaveMessage();


    /* First: stop device */

    IssueStop(device);


    /* Wait for STOP complete */

    while( device->blocked )
	DevHelp_Beep(25000, 3000);		/* wait some time */

    if( !device->stopped )			/* not successfull? */
    {
	sprintk(szMsgBuffer, szStopFailed, (PSZ)szDriverName,
		device->iAdapter, device->iUnit, device->lasterror);
	SaveMessage();
	DumpStatusblock(&device->statusblock);
	return 2;
    }


    /* Some devices may have problems restarting immediately
     * after a stop.  Wait some time? */

    DevHelp_Beep(25000, 1000);			/* wait some time */


    /* Second: device should also be restartable... */

    flag = IssueStart(device);
    if( flag )					/* Errors? */
    {
	sprintk(szMsgBuffer, szNoStart, (PSZ)szDriverName,
		device->iAdapter, device->iUnit);
	SaveMessage();
	return 3;
    }

    /* Wait for START complete */

    while( device->blocked )
	DevHelp_Beep(25000, 3000);		/* wait some time */

    if( device->stopped )			/* not successfull? */
    {
	sprintk(szMsgBuffer, szStartFailed, (PSZ)szDriverName,
		device->iAdapter, device->iUnit, device->lasterror);
	SaveMessage();
	DumpStatusblock(&device->statusblock);
	return 4;
    }


    /* Only reason to execute the code below: device test
     * completed successfully. */

    sprintk(szMsgBuffer, szTestComplete, (PSZ)szDriverName,
	    device->iAdapter, device->iUnit);
    SaveMessage();
    return 0;
} /* end[TestOperation] */




/*# ----------------------------------------------------------------------
 * CheckAdapterInfo(iAdapter,npAdapterInfo)
 *
 * PARAMETER
 *	iAdapter		global index of adapter
 *	npAdapterInfo		from GET_DEVICE_TABLE
 * RETURNS
 *	0		OK to process units here
 *	/0		no SCSI, defect, ...
 * GLOBAL
 *	none
 * DESPRIPTION
 *	Checks various flags in adapter information.  Displays
 *	some nice-to-know thing when DEBUG:1
 * REMARKS
 */
PRIVATE int NEAR
CheckAdapterInfo(USHORT const iAdapter,NPADAPTERINFO const npAdapterInfo)
{
    USHORT	devbus = (npAdapterInfo->AdapterDevBus & 0x000F);

    if( (fDriverFlags & DF_DEBUG)
       &&  !(npAdapterInfo->AdapterFlags & AF_16M) )
    {
	sprintk(szMsgBuffer, szNo16M, (PSZ)szDriverName, iAdapter);
	SaveMessage();
    }
    if( (fDriverFlags & DF_DEBUG)
       &&  !(npAdapterInfo->AdapterFlags & AF_HW_SCATGAT) )
    {
	sprintk(szMsgBuffer, szNoScGa, (PSZ)szDriverName, iAdapter);
	SaveMessage();
    }

    if( !(devbus == AI_DEVBUS_SCSI_1
	  ||  devbus == AI_DEVBUS_SCSI_2  ||  devbus == AI_DEVBUS_SCSI_3) )
    {
	/* No SCSI devices to expect on non-SCSI bus,
	 * ignore adapter. */

	if( (fDriverFlags & DF_DEBUG) )
	{
	    sprintk(szMsgBuffer, szNoSCSI, (PSZ)szDriverName,
		    iAdapter, npAdapterInfo->AdapterDevBus);
	    SaveMessage();
	}
	return 1;
    }

    return 0;
} /* end[CheckAdapterInfo] */




/*# ----------------------------------------------------------------------
 * CheckUnitInfo(iAdapter,npUnitInfo)
 *
 * PARAMETER
 *	iAdapter	global index of adapter
 *	npUnitInfo	from GET_DEVICE_TABLE
 * RETURNS
 *	0		OK, try/use this unit
 *	/0		bad type, defective, etc.
 * GLOBAL
 *	none
 * DESPRIPTION
 *	If this unit isn't a disk or a disk but a diskette, skip this
 *	unit.  Could be expanded to allow more device types in the
 *	future.
 *	Removable media mostly stops by itself and is no so easy to
 *	support as it could be removed anytime.
 *	If this unit is defect or the ADD command line indicates
 *	NO DASD/SCSI support then skip the unit, too.
 * REMARKS
 */
PRIVATE int NEAR
CheckUnitInfo(USHORT const iAdapter, NPUNITINFO const npUnitInfo)
{
    USHORT const utype = npUnitInfo->UnitType;
    USHORT const uflags = npUnitInfo->UnitFlags;


    if( utype != UIB_TYPE_DISK )
    {
	if( (fDriverFlags & DF_DEBUG) )
	{
	    sprintk(szMsgBuffer, szNoDiskType, (PSZ)szDriverName,
		    iAdapter, npUnitInfo->UnitIndex);
	    SaveMessage();
	}
	return 1;
    }

    if( (uflags & UF_REMOVABLE) )
    {
	if( (fDriverFlags & DF_DEBUG) )
	{
	    sprintk(szMsgBuffer, szRemovable, (PSZ)szDriverName,
		    iAdapter, npUnitInfo->UnitIndex);
	    SaveMessage();
	}
	return 2;
    }

    if( (uflags & (UF_A_DRIVE | UF_B_DRIVE)) )
    {
	if( (fDriverFlags & DF_DEBUG) )
	{
	    sprintk(szMsgBuffer, szDiskette, (PSZ)szDriverName,
		    iAdapter, npUnitInfo->UnitIndex);
	    SaveMessage();
	}
	return 3;
    }

    if( (uflags & UF_DEFECTIVE) )
    {
	if( (fDriverFlags & DF_VERBOSE) )
	{
	    sprintk(szMsgBuffer, szDefective, (PSZ)szDriverName,
		    iAdapter, npUnitInfo->UnitIndex);
	    SaveMessage();
	}
	return 4;
    }

    return 0;
} /* end[CheckUnitInfo] */




/*# ----------------------------------------------------------------------
 * InstallFilter(npDevice)
 *
 * PARAMETER
 *	npDevice	local structure
 *
 * RETURNS
 *	0		OK
 *	/0		something failed, skip this device
 *
 * GLOBAL
 *	hdThisDriver
 *
 * DESPRIPTION
 *	To install our filter we have to change the unit
 *	information of this device.  To change the unit info
 *	of a device we have to allocate it (but don't forget
 *	to deallocate afterwards).
 *
 * REMARKS
 *	Call DevHelp_RegisterDevClass() as late as possible.
 *	A registered driver returning 'don't install' will
 *	panic the kernel. :-(
 */
PRIVATE int NEAR
InstallFilter(NPDEVICE const npDevice)
{
    int rc = 0;

    DEBMSG1(dszInstFilter,npDevice);

    /* Send request to ALLOCATE UNIT.  May be done without registering
     * our driver. */

    {
	NPIORB_UNIT_CONTROL pIOUC = (NPVOID)npInitData;
	USHORT		failed;

	memset(pIOUC, 0, MAX_IORB_SIZE);
	pIOUC->iorbh.Length =		sizeof(IORB_UNIT_CONTROL);
	pIOUC->iorbh.UnitHandle =	npDevice->hdADDUnit;
	pIOUC->iorbh.CommandCode =	IOCC_UNIT_CONTROL;
	pIOUC->iorbh.CommandModifier =	IOCM_ALLOCATE_UNIT;

	failed = SendIORB((PIORB)pIOUC, npDevice->pADDEntry);

	npDevice->iotype = DSKIO_ALLOC;
	npDevice->laststatus = pIOUC->iorbh.Status;
	npDevice->lasterror = pIOUC->iorbh.ErrorCode;
	if( failed )
	{
	    sprintk(szMsgBuffer, szAllocFailed, (PSZ)szDriverName,
		    npDevice->iAdapter, npDevice->iUnit);
	    SaveMessage();
	    return 1;
	}
    }


    /* If requested, test START STOP UNIT.  Even this can be done
     * without a registered driver.
     * Skip device testing if this device has stopping [currently]
     * disabled. */

    if( (fDriverFlags & DF_TESTOP)  &&  npDevice->usSleep != 0 )
    {
	if( TestOperation(npDevice) )
	    rc = 2;
    }


    /* *Now* it's time to register this filter driver.
     * But --- naturally --- only if the above code succeeded
     * and we haven't done it yet. */

    if( rc == 0  &&  (fDriverFlags & DF_REGDEVCLASS) == 0 )
    {
	BOOL	b;

	DEBMSG(dszRegister);
	b = DevHelp_RegisterDeviceClass((NPSZ)szDriverName,
					(PFN)FilterFunction,
					(USHORT)DRIVERFLAGS,
					(USHORT)DRIVERCLASS_ADD,
					(PUSHORT)&hdThisDriver);
	if( b )
	{
	    sprintk(szMsgBuffer, szRegDevClassFailed, (PSZ)szDriverName);
	    SaveMessage();
	    rc = 3;
	}
	else
	    fDriverFlags |= DF_REGDEVCLASS;	/* done! */
    }


    /* If all previous actions completed successfully, modify
     * the device structure by sending a CHANGE UNITINFO */

    if( rc == 0 )
    {
	NPIORB_UNIT_CONTROL pIOUC = (NPVOID)npInitData;
	USHORT		failed;


	/* Insert late-breaking-news in device structure */

	npDevice->modinfo.FilterADDHandle = hdThisDriver;


	memset(pIOUC, 0, MAX_IORB_SIZE);
	pIOUC->iorbh.Length =		sizeof(IORB_UNIT_CONTROL);
	pIOUC->iorbh.UnitHandle =	npDevice->hdADDUnit;
	pIOUC->iorbh.CommandCode =	IOCC_UNIT_CONTROL;
	pIOUC->iorbh.CommandModifier =	IOCM_CHANGE_UNITINFO;

	pIOUC->pUnitInfo =		&npDevice->modinfo;
	pIOUC->UnitInfoLen =		sizeof(UNITINFO);

	failed = SendIORB((PIORB)pIOUC, npDevice->pADDEntry);

	npDevice->iotype = DSKIO_CHANGEUI;
	npDevice->laststatus = pIOUC->iorbh.Status;
	npDevice->lasterror = pIOUC->iorbh.ErrorCode;
	if( failed )
	{
	    sprintk(szMsgBuffer, szChangeUInfoFailed,
		    (PSZ)szDriverName, npDevice->iAdapter, npDevice->iUnit);
	    SaveMessage();

	    /* No return!  We have to deallocate!! */

	    rc = 4;
	}
    }

    {
	NPIORB_UNIT_CONTROL pIOUC = (NPVOID)npInitData;
	USHORT		failed;

	/* Send request to DEALLOCATE UNIT */

	memset(pIOUC, 0, MAX_IORB_SIZE);
	pIOUC->iorbh.Length =		sizeof(IORB_UNIT_CONTROL);
	pIOUC->iorbh.UnitHandle =	npDevice->hdADDUnit;
	pIOUC->iorbh.CommandCode =	IOCC_UNIT_CONTROL;
	pIOUC->iorbh.CommandModifier =	IOCM_DEALLOCATE_UNIT;

	failed = SendIORB((PIORB)pIOUC, npDevice->pADDEntry);

	npDevice->iotype = DSKIO_DEALLOC;
	npDevice->laststatus = pIOUC->iorbh.Status;
	npDevice->lasterror = pIOUC->iorbh.ErrorCode;
	if( failed )
	{
	    /* Couldn't deallocte unit.
	     * Bad, display and ignore */

	    sprintk(szMsgBuffer, szDeallocFailed,
		    (PSZ)szDriverName, npDevice->iAdapter, npDevice->iUnit);
	    SaveMessage();
	}
    }

    DEBMSG(dszInstFilterEnd);
    return rc;
} /* end[InstallFilter] */




/*# ----------------------------------------------------------------------
 * RemoveFilter(npDevice)
 *
 * PARAMETER
 *	npDevice	device structure
 * RETURNS
 *	0		ok, removed
 *	/0		error, not removed
 * GLOBAL
 *	none
 * DESPRIPTION
 *	Removes filter of 'npDevice' from ADD's structures
 *	(unit info).
 * REMARKS
 */
PRIVATE int NEAR
RemoveFilter(NPDEVICE const npDevice)
{
    int rc = 0;

    DEBMSG(dszRemoveFilter);
    {
	NPIORB_UNIT_CONTROL pIOUC = (NPVOID)npInitData;
	USHORT		failed;

	/* Send request to ALLOCATE UNIT */

	memset(pIOUC, 0, MAX_IORB_SIZE);
	pIOUC->iorbh.Length =		sizeof(IORB_UNIT_CONTROL);
	pIOUC->iorbh.UnitHandle =	npDevice->hdADDUnit;
	pIOUC->iorbh.CommandCode =	IOCC_UNIT_CONTROL;
	pIOUC->iorbh.CommandModifier =	IOCM_ALLOCATE_UNIT;

	failed = SendIORB((PIORB)pIOUC, npDevice->pADDEntry);

	npDevice->iotype = DSKIO_ALLOC;
	npDevice->laststatus = pIOUC->iorbh.Status;
	npDevice->lasterror = pIOUC->iorbh.ErrorCode;
	if( failed )
	{
	    sprintk(szMsgBuffer, szAllocFailed,
		    (PSZ)szDriverName, npDevice->iAdapter, npDevice->iUnit);
	    SaveMessage();
	    return 1;
	}
    }

    /* Restore previous unit info */

    npDevice->modinfo.FilterADDHandle = npDevice->hdFilter;
    npDevice->modinfo.UnitHandle = npDevice->hdADDUnit;

    {
	NPIORB_UNIT_CONTROL pIOUC = (NPVOID)npInitData;
	USHORT		failed;

	/* Send request to CHANGE UNITINFO */

	memset(pIOUC, 0, MAX_IORB_SIZE);
	pIOUC->iorbh.Length =		sizeof(IORB_UNIT_CONTROL);
	pIOUC->iorbh.UnitHandle =	npDevice->hdADDUnit;
	pIOUC->iorbh.CommandCode =	IOCC_UNIT_CONTROL;
	pIOUC->iorbh.CommandModifier =	IOCM_CHANGE_UNITINFO;

	pIOUC->pUnitInfo =		&npDevice->modinfo;
	pIOUC->UnitInfoLen =		sizeof(UNITINFO);

	failed = SendIORB((PIORB)pIOUC, npDevice->pADDEntry);

	npDevice->iotype = DSKIO_CHANGEUI;
	npDevice->laststatus = pIOUC->iorbh.Status;
	npDevice->lasterror = pIOUC->iorbh.ErrorCode;
	if( failed )
	{
	    sprintk(szMsgBuffer, szChangeUInfoFailed,
		    (PSZ)szDriverName, npDevice->iAdapter, npDevice->iUnit);
	    SaveMessage();

	    /* No return!  We have to deallocate!! */

	    rc = 2;
	}
    }

    {
	NPIORB_UNIT_CONTROL pIOUC = (NPVOID)npInitData;
	USHORT		failed;

	/* Send request to DEALLOCATE UNIT */

	memset(pIOUC, 0, MAX_IORB_SIZE);
	pIOUC->iorbh.Length =		sizeof(IORB_UNIT_CONTROL);
	pIOUC->iorbh.UnitHandle =	npDevice->hdADDUnit;
	pIOUC->iorbh.CommandCode =	IOCC_UNIT_CONTROL;
	pIOUC->iorbh.CommandModifier =	IOCM_DEALLOCATE_UNIT;

	failed = SendIORB((PIORB)pIOUC, npDevice->pADDEntry);

	npDevice->iotype = DSKIO_DEALLOC;
	npDevice->laststatus = pIOUC->iorbh.Status;
	npDevice->lasterror = pIOUC->iorbh.ErrorCode;
	if( failed )
	{
	    /* Couldn't deallocte unit.
	     * Bad, display and ignore */

	    sprintk(szMsgBuffer, szDeallocFailed,
		    (PSZ)szDriverName, npDevice->iAdapter, npDevice->iUnit);
	    SaveMessage();
	}
    }

    return rc;
} /* end[RemoveFilter] */




/*# ----------------------------------------------------------------------
 * Add2TOTable(aidx,uidx,to)
 *
 * PARAMETER
 *	aidx,uindx	device coords
 *	to		timeout value
 * RETURNS
 *	nothing
 * GLOBAL
 *	ToOption[]
 * DESPRIPTION
 *	Adds entry to global table to set unit specific timeout.
 * REMARKS
 */
PRIVATE void NEAR
Add2TOTable(USHORT const aidx,USHORT const uidx,USHORT const to)
{
    int i;

    if( aidx > 0x007F  ||  uidx > 0xFF )
	return;					/* quiet fail */

    for( i = 0; i < MAX_UNITS; ++i )
    {
	if( (ToOption[i].adpno & 0x80) == 0 )
	{
	    ToOption[i].adpno = (UCHAR)(aidx | 0x80);
	    ToOption[i].unitno = (UCHAR)uidx;
	    ToOption[i].to = to;
	    break;
	}
	else if( (UCHAR)(ToOption[i].adpno & ~0x80) == aidx
		&&  ToOption[i].unitno == uidx )
	{
	    ToOption[i].to = to;
	    break;
	}
    }

    return;
}




/*# ----------------------------------------------------------------------
 * QueryTOTable(aidx,uidx)
 *
 * PARAMETER
 *	aidx,uidx	device coords
 * RETURNS
 *	pointer to ToOption[] entry or NULL
 * GLOBAL
 *	ToOption[]
 * DESPRIPTION
 *	Retrieve special timeout settings for this
 *	device, if available.
 * REMARKS
 */
PRIVATE TO_OPTION FAR * NEAR
QueryTOTable(USHORT const aidx,USHORT const uidx)
{
    int i;

    if( aidx > 0x007F  ||  uidx > 0xFF )
	return 0;				/* quiet fail */

    for( i = 0; i < MAX_UNITS; ++i )
    {
	if( (ToOption[i].adpno & 0x80)
	   &&  (UCHAR)(ToOption[i].adpno & ~0x80) == aidx
	   &&  ToOption[i].unitno == uidx )
	{
	    return &ToOption[i];
	}
    }

    return 0;					/* let compiler expand... */
}




/*# ----------------------------------------------------------------------
 * ScanDevices(void)
 *
 * PARAMETER
 *	none
 * RETURNS
 *	0		OK, install driver
 *	<0		fatal error, loud abort
 *	>0		no device found, be quiet
 * GLOBAL
 *	anpUnit
 *	npInitData
 *	fDriverFlags
 * DESPRIPTION
 *	Scans all adapters on all ADDs for a SCSI disk device
 *	which isn't removable.
 *	Adds found devices to global list.  Handles already
 *	installed filter drivers.
 * REMARKS
 */
PRIVATE int NEAR
ScanDevices(void)
{
    USHORT	j, k;
    int		fatal = 0;

    USHORT	add_count, add_index, adapter_index;

    void	(FAR _Cdecl * pADDBaseEP)(PIORB);

    struct DevClassTableEntry FAR *pDCE;
    struct DevClassTableStruc FAR *pDCT;


    DEBMSG(dszScanDevices);

    /* Get address of Registered ADD Table */

    if( DevHelp_GetDOSVar(DHGETDOSV_DEVICECLASSTABLE,DRIVERCLASS_ADD,(PPVOID)&pDCT) )
    {
	/* Should never happen.	 What can we do? */

	sprintk(szMsgBuffer, szNoDriverTab, (PSZ)szDriverName);
	SaveMessage();
	return -1;
    }

    add_count = pDCT->DCCount;


    /* For each ADD registered	*/

    DEBMSG(dszAddScan);
    for( pDCE = pDCT->DCTableEntries, add_index = 0, adapter_index = 0;
	add_index < add_count;
	++add_index, ++pDCE )
    {
	{
	    NPIORB_CONFIGURATION pIOCF = (NPVOID)npInitData;

	    /* Get ADD's Device Table */

	    memset(pIOCF, 0, MAX_IORB_SIZE);
	    pIOCF->iorbh.Length =		sizeof(IORB_CONFIGURATION);
	    pIOCF->iorbh.UnitHandle =		0;
	    pIOCF->iorbh.CommandCode =		IOCC_CONFIGURATION;
	    pIOCF->iorbh.CommandModifier =	IOCM_GET_DEVICE_TABLE;

	    pIOCF->pDeviceTable =	(PDEVICETABLE)DeviceTable;
	    pIOCF->DeviceTableLen =	sizeof(DeviceTable);

	    pADDBaseEP = (PVOID)MAKEP(pDCE->DCSelector, pDCE->DCOffset);

	    if( SendIORB((PIORB)pIOCF, pADDBaseEP) )
	    {
		/* Error (?), could not get device table of installed
		 * ADD.	 Just ignore that ADD (which probably hasn't
		 * any adapters/devices, either). */

		sprintk(szMsgBuffer, szNoDevTab, (PSZ)szDriverName, add_index);
		SaveMessage();
		continue;
	    }
	}


	/* For each Adapter in ADD's Device Table */

	DEBMSG(dszAdpScan);
	for( j = 0;
	    j < ((PDEVICETABLE)DeviceTable)->TotalAdapters;
	    ++j, ++adapter_index )
	{
	    NPADAPTERINFO const npAdapterInfo
		= ((PDEVICETABLE)DeviceTable)->pAdapter[j];
	    NPUNITINFO		npUnitInfo;


	    if( CheckAdapterInfo(adapter_index, npAdapterInfo) )
		continue;

	    /* Access UNITINFO for each Device on adapter */

	    DEBMSG(dszUnitScan);
	    for( npUnitInfo = npAdapterInfo->UnitInfo, k = 0;
		k < npAdapterInfo->AdapterUnits;
		++k, ++npUnitInfo )
	    {
		void	(FAR _Cdecl * pADDEntry)();
		USHORT	FilterADDHandle;

		/* If a Filter ADD has been registered for this unit
		 * then send subsequent requests to the Filter ADD
		 * and not to the ADD. */

		if( (FilterADDHandle = npUnitInfo->FilterADDHandle) != 0 )
		{
		    struct DevClassTableEntry FAR *pDCEFilter;

		    DEBMSG(dszOldFilter);
		    pDCEFilter = &pDCT->DCTableEntries[FilterADDHandle-1];

		    pADDEntry = (PVOID)MAKEP(pDCEFilter->DCSelector,
					     pDCEFilter->DCOffset);
		}
		else
		{
		    pADDEntry = pADDBaseEP;
		}

		if( CheckUnitInfo(adapter_index, npUnitInfo) )
		    continue;


		/* We handle this unit, allocate some memory
		 * in global table to hold neccessary data.
		 * Needed at least:
		 * - entry point of ADD (or filter)
		 * - modified unit info */

		GETINITRAM(anpUnit[cUnit],NPDEVICE,sizeof(DEVICE));
		memset(anpUnit[cUnit], 0, sizeof(DEVICE));
		DEBMSG1(dszUnitAlloc,anpUnit[cUnit]);

		anpUnit[cUnit]->pADDEntry = (PVOID)pADDEntry;
		anpUnit[cUnit]->hdADDUnit = npUnitInfo->UnitHandle;
		anpUnit[cUnit]->hdFilter = FilterADDHandle;

#if defined(_MSC_VER)
		_asm { cld }			/* seems to be a bug in MS-C */
#endif
		anpUnit[cUnit]->modinfo = *npUnitInfo;

		anpUnit[cUnit]->modinfo.UnitHandle = (USHORT)anpUnit[cUnit];
		anpUnit[cUnit]->iAdapter = adapter_index;
		anpUnit[cUnit]->iUnit = npUnitInfo->UnitIndex;

		anpUnit[cUnit]->cdbStart[0] = 0x1B;
		anpUnit[cUnit]->cdbStart[1] = (UCHAR)(npUnitInfo->UnitSCSILUN << 5);
		anpUnit[cUnit]->cdbStart[4] = 0x01;

		anpUnit[cUnit]->cdbStop[0] = 0x1B;
		anpUnit[cUnit]->cdbStop[1] = (UCHAR)(npUnitInfo->UnitSCSILUN << 5);
		anpUnit[cUnit]->cdbStop[4] = 0;

		anpUnit[cUnit]->cdbTestReady[0] = 0;
		anpUnit[cUnit]->cdbTestReady[1] = (UCHAR)(npUnitInfo->UnitSCSILUN << 5);

		{
		    TO_OPTION FAR * p = QueryTOTable(anpUnit[cUnit]->iAdapter,
						     anpUnit[cUnit]->iUnit);

		    if( p != 0 )
			anpUnit[cUnit]->usSleep = p->to;
		    else
			anpUnit[cUnit]->usSleep = usSleepSeconds;
		}

		if( InstallFilter(anpUnit[cUnit]) )
		{
		    /* Couldn't allocate unit.	Release
		     * any data allocated and continue with
		     * next device. */

		    anpUnit[cUnit] = 0;
		    npInitData -= sizeof(DEVICE);	/* free memory */
		    ++fatal;				/* that may be fatal */
		    continue;
		}

		if( (fDriverFlags & DF_VERBOSE) )
		{
		    sprintk(szMsgBuffer, szFoundDevice,
			    anpUnit[cUnit]->iAdapter, anpUnit[cUnit]->iUnit,
			    anpUnit[cUnit]->usSleep/60U);
		    SaveMessage();
		}

		++cUnit;			/* one more for us */
	    } /* for each unit */
	} /* for each adapter */
    } /* for each ADD */


    if( fatal )					/* errors occurred? */
    {
	USHORT i;

	/* A fatal error occurred during scanning, we cannot
	 * install this driver.	 But there may be devices where
	 * our driver is referenced, remove that pointer.
	 * Ignore any errors, don't release memory (won't
	 * install at all). */

	for( i = 0; i < cUnit; ++i )
	    RemoveFilter(anpUnit[i]);
	return -1;				/* than display and wait */
    }
    if( cUnit == 0 )
    {
	if( (fDriverFlags & DF_VERBOSE) )
	{
	    sprintk(szMsgBuffer, szNoDevices, (PSZ)szDriverName);
	    SaveMessage();
	}
	return 1;				/* non-fatal error */
    }
    return 0;
}




/*#
 * InstallTimer(void)
 *
 * PARAMETER
 *	none
 * RETURNS
 *	0		OK
 *	/0		error, no timer installed
 * GLOBAL
 *	none
 * DESPRIPTION
 *	Install a timer handler so we can detect when
 *	to stop a device.
 * REMARKS
 */
PRIVATE int NEAR
InstallTimer(void)
{
    DEBMSG(dszInstallTimer);
    if( DevHelp_TickCount((NPFN)&AsmTimer,
			  TIMER_TMS/pGlobalInfoSeg->SIS_ClkIntrvl) )
    {
	sprintk(szMsgBuffer, szNoTimer, (PSZ)szDriverName);
	SaveMessage();
	return 1;
    }
    return 0;
}




#define ENTRY_STATE	   0
#define MAX_STATES	   2

/*
 *					opt.state[] initialization definitions
 *
 *						____ entry state
 *						|		previous
 *						v		  opt	|
 *  ----Command Line Option --------		----- STATE TABLE ----- |
 *  token id		string	type		0   1	2		|
 *									|
 *						*  /A:	/A:	 <-------
 *							 plus
 */
#define TOK_ID_NOT_APM	100
#define TOK_ID_APM	101

OPT OPT_VERBOSE =
    {TOK_ID_VERBOSE,0,	"/V", TYPE_0,		{0,  E,	 E}};

OPT OPT_NSR =
    {TOK_ID_NOT_SR,0,	"/!SR", TYPE_0,		{0,  E,	 E}};

OPT OPT_SR =
    {TOK_ID_SR,0,	"/SR", TYPE_0,		{0,  E,	 E}};

OPT OPT_DEBUG_DEFAULT =
    {TOK_ID_DEBUG,0,	"/DEBUG", TYPE_0,	{0,  E,	 E}};

OPT OPT_DEBUG_NO =
    {TOK_ID_DEBUG,0,	"/DEBUG:", TYPE_D,	{0,  E,	 E}};

OPT OPT_TIME =
    {TOK_ID_TIME,0,	"/T:", TYPE_DDDD,	{0,  E,	 E}};

OPT OPT_NUT =
    {TOK_ID_NOT_UT,0,	"/!UT:", TYPE_ULIST,	{0,  E,	 E}};

OPT OPT_UT =
    {TOK_ID_UT,0,	"/UT:", TYPE_ULIST,	{0,  E,	 E}};

OPT OPT_NAPM =
    {TOK_ID_NOT_APM,0,	"/!APM", TYPE_0,	{0,  E,	 E}};

OPT OPT_APM =
    {TOK_ID_APM,0,	"/APM", TYPE_0,		{0,  E,	 E}};

OPT OPT_END =
    {TOK_ID_END,0,	"\0", TYPE_0,		{O,  O,	 O}};


/*
 *
 *   The following is a generic OPTIONTABLE for ADDs which support SCSI
 *   devices.
 *
 *   Please note the importance of the ordering of entries in poption[]
 *   For example: the pointer to the option "/DM:" must come before the
 *   option "/DM"
 */
OPTIONTABLE  opttable = {
    ENTRY_STATE, MAX_STATES,
    {
	&OPT_VERBOSE,
	&OPT_NSR,
	&OPT_SR,
	&OPT_DEBUG_NO,
	&OPT_DEBUG_DEFAULT,
	&OPT_TIME,
	&OPT_NUT,
	&OPT_UT,
	&OPT_NAPM,
	&OPT_APM,
	&OPT_END
    }
};



/*# ----------------------------------------------------------------------
 * AnalyseCmdLine(pszLine)
 *
 * PARAMETER
 *	pszLine		pointer to command line
 * RETURNS
 *	0		OK
 * GLOBAL
 * DESPRIPTION
     Invoke parser and analyse token output.
 * REMARKS
 */
PRIVATE int NEAR
AnalyseCmdLine(PSZ pszLine)
{
    CC		parse_rc;
    PUCHAR	cp;
    int		i;
    UCHAR	TokenId;


    /* Call IBM supplied parser with the above defined option
     * table. */

    parse_rc = Command_Parser(pszLine, &opttable,
			      DeviceTable, MAX_DEVICETABLE_SIZE);

    /* Process errors. Although errors were detected the
     * command line and 'DeviceTable' may contain valid tokens
     * which have to be processed later, so only use 'break'
     * in 'case' clauses. */

    switch( parse_rc.ret_code )
    {
	/* SYNTAX_ERR:
	 *	General error in command line, no special handling
	 */
      case SYNTAX_ERR:
	sprintk(szMsgBuffer, szCmdLineSyntax, (PSZ)szDriverName);
	SaveMessage();
	break;

	/* REQ_OPT_ERR:
	 *	Required option is missing in command line (probably /A: )
	 */
      case REQ_OPT_ERR:
	sprintk(szMsgBuffer, szMissingOption, (PSZ)szDriverName);
	SaveMessage();
	break;

	/* INVALID_OPT_ERR:
	 *	Bad format?
	 */
      case INVALID_OPT_ERR:
	sprintk(szMsgBuffer, szUnknownOption,
		(PSZ)szDriverName, (PBYTE)DeviceTable);
	SaveMessage();
	break;

      case UNDEFINED_TYPE_ERR:
      case UNDEFINED_STATE_ERR:
      case BUF_TOO_SMALL_ERR:
      default:
	sprintk(szMsgBuffer, szCmdLineError,
		(PSZ)szDriverName, parse_rc.ret_code);
	SaveMessage();
      case NO_OPTIONS_FND_ERR:
      case NO_ERR:
	break;
    }

    for( cp = DeviceTable;
	 (TokenId=*(cp+TOKL_ID)) != TOK_ID_END;
	 cp += *(cp+TOKL_LEN) )
    {
	switch( TokenId )
	{
	  case TOK_ID_VERBOSE:
	    fDriverFlags |= DF_VERBOSE;
	    break;

	  case TOK_ID_APM:
	    fDriverFlags &= ~DF_NOAPM;
	    break;

	  case TOK_ID_NOT_APM:
	    fDriverFlags |= DF_NOAPM;
	    break;

	  case TOK_ID_SR:
	    fDriverFlags |= DF_SHUTDOWN;
	    break;

	  case TOK_ID_NOT_SR:
	    fDriverFlags &= ~DF_SHUTDOWN;
	    break;

	  case TOK_ID_DEBUG:
	    fDriverFlags |= DF_VERBOSE;
	    fDriverFlags |= DF_DEBUG;

	    if( *(cp+TOKL_LEN) == TOK_MIN_LENGTH+1 )
	    {
		UCHAR code = *(cp+TOKL_VALUE);

		switch( code )
		{
		  case 1:
		    fDriverFlags |= DF_TESTOP;
		    break;

		  default:
		    sprintk(szMsgBuffer, szUnknownOption,
			    (PSZ)szDriverName, (PBYTE)DeviceTable);
		    SaveMessage();
		    break;
		}
	    }
	    break;

	  case TOK_ID_UT:
	    for( i = 0;
		i < *(cp+TOKL_LEN)-2;
		i += 6 )			/* for every coordinate */
	    {
		USHORT time = usSleepSeconds;	/* current active setting */

		if( *(PUSHORT)(cp+TOKL_VALUE+i+4) != 0 )
		    time = *(PUSHORT)(cp+TOKL_VALUE+i+4) * 60U;

		Add2TOTable(*(PUSHORT)(cp+TOKL_VALUE+i),
			    *(PUSHORT)(cp+TOKL_VALUE+i+2), time);
	    }
	    break;

	  case TOK_ID_NOT_UT:
	    for( i = 0;
		i < *(cp+TOKL_LEN)-2;
		i += 6 )			/* for every coordinate */
	    {
		if( *(PUSHORT)(cp+TOKL_VALUE+i+4) != 0 )
		{
		    sprintk(szMsgBuffer, szCmdLineSyntax, (PSZ)szDriverName);
		    SaveMessage();
		}
		else
		    Add2TOTable(*(PUSHORT)(cp+TOKL_VALUE+i),
				*(PUSHORT)(cp+TOKL_VALUE+i+2),
				0);
	    }
	    break;

	  case TOK_ID_TIME:
	    {
		USHORT time = *(PUSHORT)(cp+TOKL_VALUE);

		usSleepSeconds = time * 60U;
	    }
	    break;

	  case TOK_ID_END:
	    break;

	  default:
	    DBSTOP();
	    break;
	}
    }

    return 0;
} /*end[AnalyseCmdLine]*/




/*
 * CALL
 *	CheckRegistration(void)
 * PARAMETER
 *	none
 * RETURNS
 *	nothing
 * GLOBAL
 *	fDriverFlags updated
 * DESPRIPTION
 *	Sets DF_REGISTERED in fDriverFlags depending on
 *	registration code.
 * REMARKS
 */
PRIVATE void NEAR
CheckRegistration(void)
{
    UCHAR code[REG_KEYLEN];
    UCHAR c;
    int i;
    UCHAR _far *p, _far *k;

    _fmemset(code, 0, REG_KEYLEN);
    for( c = 0, i = 0, p = RegData.szUser, k = szProduct;
	*p != '\0';
	++p, ++i, k = (*(k+1) == '\0' ? szProduct : k+1) )
    {
	c = (UCHAR)((*p & 0xf0) >> 4 | (*p & 0x0f));
	c *= *k;
	c += *k;
	code[i] = c;
    }
    if( i != 0	&&  _fmemcmp(code, RegData.szRegCode, i) == 0 )
	fDriverFlags |= DF_REGISTERED;
    return;
}






/* **********************************************************************
 * **** Public Entries **************************************************
 * ******************************************************************* */


/*#
 * InitBase(pRPI)
 *
 * PARAMETER
 *	pRPI		init request
 * RETURNS
 *	error code as expected from the OS/2 device system
 * GLOBAL
 *	Device_Help
 *	pGlobalInfoSeg
 *	fDriverFlags
 *	szDriverName, error messages
 * DESPRIPTION
 *	Process Base Initialization Request Packet
 * REMARKS
 *	Uses IBM supplied command line parser.
 */
PUBLIC USHORT NEAR
InitBase(PRPINITIN pRPI)
{
    PULONG		pInfoSegSel;
    int			rc;
    PRPINITOUT const	pRPO = (PRPINITOUT)pRPI;
    PDDD_PARM_LIST const pInitParms = (PDDD_PARM_LIST)pRPI->InitArgs;
    PSZ			pCmdLine;

    DBSTOP();

    /* Contains entry point to kernel functions */

    Device_Help = pRPI->DevHlpEP;
    pCmdLine	= MK_FP(FP_SEL(pInitParms),pInitParms->cmd_line_args);

    DevHelp_GetDOSVar(DHGETDOSV_SYSINFOSEG, 0, (PPVOID)&pInfoSegSel);
    pGlobalInfoSeg = MAKEP(*pInfoSegSel, 0);


    /* Parse Command Line Args */

    AnalyseCmdLine(pCmdLine);

    CheckRegistration();

    if( !(fDriverFlags & DF_REGISTERED) )
	fDriverFlags |= DF_VERBOSE;
    if( (fDriverFlags & DF_VERBOSE) )
    {
	sprintk(szMsgBuffer, szLogo, (PSZ)szProduct, VERSION, SUBVERSION);
	SaveMessage();
	if( (fDriverFlags & DF_REGISTERED) )
	{
	    sprintk(szMsgBuffer, szReg, (PSZ)RegData.szUser);
	    SaveMessage();
	}
	else
	{
	    sprintk(szMsgBuffer, szNoReg);
	    SaveMessage();
	}
    }


    rc = ScanDevices();
    if( rc == 0 )
    {
	rc = InstallTimer();
    }

    /* Processing complete.  Analyse situation, should we install,
     * quiet fail or even loudly stop Config.Sys processing? */

    if( rc == 0 )
    {
	/* We do not need to register any units, since this
	 * filter does not generate any units on his own. */

	pRPO->Unit = 0;
	pRPO->CodeEnd = ((USHORT)Code_End & ~0x0F) + 0x10;
	pRPO->DataEnd = ((USHORT)npInitData & ~0x0F) + 0x10;

	DEBMSG(dszInstalled);
	fDriverFlags |= DF_INITDONE;
	return STATUS_DONE;
    }
    else
    {
	pRPO->Unit = 0;
	pRPO->CodeEnd = 0;
	pRPO->DataEnd = 0;

	DEBMSG(dszNotInstalled);
	if( rc < 0 )
	    return STERR | STDON | ERROR_I24_GEN_FAILURE;
	else
	    return STERR | STDON | ERROR_I24_QUIET_INIT_FAIL;
    }
}



/* History:
 *
 * $Log: init1.c,v $
 * Revision 1.23  2001/02/16 02:12:36  vitus
 * - removed APM releated code, this is now done on INIT_COMPLETE
 *
 * Revision 1.22  1999/11/29 00:35:12  vitus
 * - moved all system includes to dsksleep.h
 * - minor changes for M$ C 7.0
 *
 * Revision 1.21  1999/11/28 23:45:30  vitus
 * - uses WAIT_IS_INTERRUPTABLE
 *
 * Revision 1.20  1998/06/29 00:01:25  vitus
 * - renamed _far_*() to _f*() (for MS-C, WatCom supplies)
 * - switched to DDK support macros (cli, pushf, etc.)
 *
 * Revision 1.19  1998/01/29 22:20:09  vitus
 * - added casts to skip two warnings
 * - uses #define INITMSG to place strings
 *
 * Revision 1.18  1997/12/05 01:33:40  vitus
 * - added WatCom specific code and header
 * - removed things declared in newer DDKs
 * - declared all exported and imported functions as _Cdecl
 * - changes for new OPT structure, removed unneccessary casts
 *
 * Revision 1.17  1997/11/23 22:37:50  vitus
 * - correctly corrected detection of non-SCSI controllers
 *
 * Revision 1.16  1997/11/22 01:07:47  vitus
 * - corrected detection of non-SCSI controllers
 *
 * Revision 1.15  1997/10/26 00:29:18  vitus
 * - longer and higher beep
 * - /!UT device aren't tested
 * - modified UnitHandle is pointer not index (better debugging)
 *
 * Revision 1.14  1997/10/24 23:30:58  vitus
 * - slower beep (lo ger)
 *
 * Revision 1.13  1997/10/11 17:44:11  vitus
 * - does driver registration *after* device test
 * - clear IORB with MAX_IORB_SIZE bytes, as most DMD do
 *
 * Revision 1.12  1997/09/03 01:02:23  vitus
 * - saves status and sense values in device structure (IOCtl retrieves)
 * - accept /!DM or /!SM units
 *
 * Revision 1.11  1997/07/21 01:13:38  vitus
 * Changed TestOperation to use IssueStart,IssueStop
 * Added /SR, /!SR tokens in AnalyseCmdLine
 * Detects APM
 *
 * Revision 1.10  1997/06/18 00:49:45  vitus
 * SendIORB() now saves,restores all registers
 *
 * Revision 1.9  1997/06/03 23:44:11  vitus
 * Removed syntax errors
 *
 * Revision 1.8  1997/05/11 14:44:12  vitus
 * Removed TAB from logo string
 *
 * Revision 1.7  1997/05/07 23:31:37  vitus
 * Added DEBMSG calls and strings
 * Devhelp_Beep now public (see iorb.c)
 * Corrected dump of status block
 * Delayed driver registration (avoids trap)
 * Shows timeout on unit display
 * Resident memory area expanded to next paragraph
 *
 * Revision 1.6	 1997/03/03 01:15:02  vitus
 * Corrected dump of sense bytes
 * Corrected adapter numbering
 * Uses SaveMessage instead of DevHelp_Save_Message
 *
 * Revision 1.5	 1997/02/06 01:08:59  vitus
 * Changed copyright to 1997 and 2:2474/424
 *
 * Revision 1.4	 1996/11/04 00:14:57  vitus
 * Better TestOperation(), corrected error display
 * Displays missing 16MB, HW S/G support (debug)
 * Parses /[!]UT tokens (timeout per device)
 *
 * Revision 1.3	 1996/10/24 00:12:25  vitus
 * Added registration check/display
 * Modularisiert
 * Added /Debug[:1] switch
 * Tests start/stop
 *
 * Revision 1.2	 1996/09/30 00:27:21  vitus
 * Added command line parsing
 *
 * Revision 1.1	 1996/09/27 02:28:09  vitus
 * Initial revision
 */
@


1.23
log
@- removed APM releated code, this is now done on INIT_COMPLETE
@
text
@d3 2
a4 2
 * $Revision: 1.22 $
 * $Date: 1999/11/29 00:35:12 $
d13 1
a13 1
static char const id[]="$Id: init1.c,v 1.22 1999/11/29 00:35:12 vitus Exp vitus $";
d1153 2
d1180 6
d1210 2
d1218 1
a1218 1
/*#
d1299 8
d1543 3
@


1.22
log
@- moved all system includes to dsksleep.h
- minor changes for M$ C 7.0
@
text
@d3 2
a4 2
 * $Revision: 1.21 $
 * $Date: 1999/11/28 23:45:30 $
d7 1
a7 1
 * First step of initialisation.
d10 2
a11 2
 * -------------------------------------------
 * This code is Copyright Vitus Jensen 1996-99
d13 1
a13 1
static char const id[]="$Id: init1.c,v 1.21 1999/11/28 23:45:30 vitus Exp vitus $";
a25 17
/* Missing in my DDK... */

#define DHGETDOSV_APMINFO	16

#pragma pack(1)
typedef struct _APMINFO {
    USHORT	APM_CodeSeg;
    USHORT	APM_DataSeg;
    USHORT	APM_Offset;
    USHORT	APM_Flags;
    USHORT	APM_Level;
    UCHAR	APM_CPUIdle[6];			/* 32Bit far address */
} APMINFO;
#pragma pack()



a98 1
INITMSG	szAvailAPM[]=	"APM is available on this machine!";
d198 1
a198 1
/*#
d224 1
a224 1
/*#
d247 1
a247 1
    USHORT	rc;
d276 1
a276 1
/*#
d297 1
a297 1
    int		flag;
d368 1
a368 1
/*#
d423 1
a423 1
/*#
d445 1
a445 1
CheckUnitInfo(USHORT const iAdapter,NPUNITINFO const npUnitInfo)
d501 1
a501 1
/*#
d672 1
a672 1
/*#
d790 1
a790 1
/*#
d835 1
a835 1
/*#
d873 1
a873 1
/*#
d1017 1
a1017 1
		anpUnit[cUnit]->pADDEntry = pADDEntry;
a1442 1
    APMINFO FAR *	pAPMInfo;
a1483 12
    /* Use Advanced Power Management (APM)? */

    DevHelp_GetDOSVar(DHGETDOSV_APMINFO, 0, (PPVOID)&pAPMInfo);
    if( (fDriverFlags & DF_DEBUG)
	&&  (pAPMInfo->APM_Flags & 0x03) != 0 )	/* 16 or 32Bit protected mode? */
    {
	/* APM is available! */

	sprintk(szMsgBuffer, szAvailAPM);
	SaveMessage();
    }

d1525 4
@


1.21
log
@- uses WAIT_IS_INTERRUPTABLE
@
text
@d3 2
a4 2
 * $Revision: 1.20 $
 * $Date: 1998/06/29 00:01:25 $
d11 1
a11 1
 * This code is Copyright Vitus Jensen 1996-97
d13 1
a13 5
#pragma off (unreferenced)
static char const id[]="$Id: init1.c,v 1.20 1998/06/29 00:01:25 vitus Exp vitus $";
#pragma on (unreferenced)

#include <string.h>
a16 7
#include <os2.h>

#include <devcmd.h>
#include <devclass.h>
#include <dskinit.h>
#include <infoseg.h>

d18 1
a18 11
#include <reqpkt.h>

#include <scsi.h>
#include <iorb.h>
#if defined(__WATCOMC__)
# include <devhelp.h>
typedef USHORT NEAR *	NPUSHORT;
typedef VOID NEAR *	NPVOID;
#else
# include <dhcalls.h>
#endif
a19 2

#include "dsksleep.h"
d216 3
a218 5
/*
 * NAME
 *	SendIORBNotify
 * CALL
 *	SendIORBNotify(iorb)
d242 3
a244 5
/*
 * NAME
 *	SendIORB
 * CALL
 *	SendIORB(iorb,addentry)
d277 1
a277 1
	rc = DevHelp_ProcBlock((ULONG)iorb, -1L, WAIT_IS_INTERRUPTABLE);
d294 3
a296 5
/*
 * NAME
 *	TestOperation
 * CALL
 *	TestOperation(device)
d386 3
a388 5
/*
 * NAME
 *	CheckAdapterInfo
 * CALL
 *	CheckAdapterInfo(iAdapter,npAdapterInfo)
d441 3
a443 5
/*
 * NAME
 *	CheckUnitInfo
 * CALL
 *	CheckUnitInfo(iAdapter,npUnitInfo)
d520 1
a520 4
 * NAME
 *	InstallFilter
 * CALL
 *	InstallFilter(npDevice)
d690 3
a692 5
/*
 * NAME
 *	RemoveFilter
 * CALL
 *	RemoveFilter(npDevice)
d808 3
a810 5
/*
 * NAME
 *	Add2TOTable
 * CALL
 *	Add2TOTable(aidx,uidx,to)
d853 3
a855 5
/*
 * NAME
 *	QueryTOTable
 * CALL
 *	QueryTOTable(aidx,uidx)
d891 3
a893 5
/*
 * NAME
 *	ScanDevices
 * CALL
 *	ScanDevices(void)
d919 1
a919 1
    void	(FAR _Cdecl * pADDBaseEP)();
d929 1
a929 1
    if( DevHelp_GetDOSVar(DHGETDOSV_DEVICECLASSTABLE, DRIVERCLASS_ADD, &pDCT) )
d1124 3
a1126 5
/*
 * NAME
 *	InstallTimer
 * CALL
 *	InstallTimer(void)
d1226 3
a1228 5
/*
 * NAME
 *	AnalyseCmdLine
 * CALL
 *	AnalyseCmdLine(pszLine)
d1440 3
a1442 5
/*
 * NAME
 *	InitBase
 * CALL
 *	InitBase(pRPI)
d1556 3
@


1.20
log
@- renamed _far_*() to _f*() (for MS-C, WatCom supplies)
- switched to DDK support macros (cli, pushf, etc.)
@
text
@d2 3
a4 3
 * $Source: d:/source/driver/sleep/RCS/init1.c,v $
 * $Revision: 1.19 $
 * $Date: 1998/01/29 22:20:09 $
d14 1
a14 1
static char const id[]="$Id: init1.c,v 1.19 1998/01/29 22:20:09 vitus Exp vitus $";
d292 1
a292 3
#if defined(_MSC_VER)
    ULONG	dummy;				/* needed for SAVE_REGS() */
#endif
d304 3
a306 1
	DevHelp_ProcBlock((ULONG)iorb, -1L, WAIT_IS_NOT_INTERRUPTABLE);
d311 2
a312 1
    return (iorb->Status & IORB_ERROR ? iorb->ErrorCode : 0);
a1441 2
 * NAME
 *	CheckRegistration
d1606 4
@


1.19
log
@- added casts to skip two warnings
- uses #define INITMSG to place strings
@
text
@d2 3
a4 3
 * $Source: e:/source/driver/sleep/RCS/init1.c,v $
 * $Revision: 1.18 $
 * $Date: 1997/12/05 01:33:40 $
d14 1
a14 1
static char const id[]="$Id: init1.c,v 1.18 1997/12/05 01:33:40 vitus Exp vitus $";
a32 1
#include <addcalls.h>
d214 1
a214 1
	    sprintk(&achDump[_far_strlen(achDump)],
d229 1
a229 1
	    sprintk(&achDump[_far_strlen(achDump)], szHex, sensedata[i]);
d301 1
a301 3
    SAVE_REGS();
    (addentry)(iorb);
    RESTORE_REGS();
d303 1
a303 1
    DISABLE();
d307 1
a307 1
	DISABLE();
d309 1
a309 1
    ENABLE();
d631 1
a631 1
	BOOL	bool;
d634 6
a639 6
	bool = DevHelp_RegisterDeviceClass((NPSZ)szDriverName,
					   (PFN)FilterFunction,
					   (USHORT)DRIVERFLAGS,
					   (USHORT)DRIVERCLASS_ADD,
					   (PUSHORT)&hdThisDriver);
	if( bool )
d1464 1
a1464 1
    _far_memset(code, 0, REG_KEYLEN);
d1474 1
a1474 1
    if( i != 0	&&  _far_memcmp(code, RegData.szRegCode, i) == 0 )
d1607 4
@


1.18
log
@- added WatCom specific code and header
- removed things declared in newer DDKs
- declared all exported and imported functions as _Cdecl
- changes for new OPT structure, removed unneccessary casts
@
text
@d3 2
a4 2
 * $Revision: 1.17 $
 * $Date: 1997/11/23 22:37:50 $
d14 1
a14 1
static char const id[]="$Id: init1.c,v 1.17 1997/11/23 22:37:50 vitus Exp vitus $";
d72 2
d103 15
a117 16
char _ininit	szNoDriverTab[]="%s: error retrieving driver table";
char _ininit	szNoDevTab[]=	"%s: error retrieving device table from ADD %u";
char _ininit	szNoSCSI[]=	"%s: adapter %u has no SCSI bus (%04x)";
char _ininit	szNo16M[]=	"%s: adapter %u doesn't support memory above 16MB";
char _ininit	szNoScGa[]=	"%s: adapter %u doesn't support HW scatter/gather";
char _ininit	szNoDiskType[]= "%s: adapter %u, unit %u is no disk device";
char _ininit	szRemovable[]=	"%s: adapter %u, unit %u is removable";
char _ininit	szDiskette[]=	"%s: adapter %u, unit %u is diskette drive";
char _ininit	szDefective[]=	"%s: adapter %u, unit %u is defect";
char _ininit	szNoSupport[]=	"%s: adapter %u, unit %u has /!DM or /!SM set";
char _ininit	szAllocFailed[]="%s: adapter %u, unit %u allocation failed";
char _ininit	szDeallocFailed[]="%s: adapter %u, unit %u, deallocation failed";
char _ininit	szChangeUInfoFailed[]="%s: adapter %u, unit %u, change unit info failed";
char _ininit	szNoTimer[]=	"%s: couldn't install timer handler";
char _ininit	szRegDevClassFailed[]=	"%s: error registering device class";
char _ininit	szNoDevices[]=	"%s: no devices found";
d121 9
a129 11
char _ininit	szTestStart[]=	"%s: adapter %u, unit %u, device test starts...";
char _ininit	szTestComplete[]= "%s: adapter %u, unit %u, device test ended successfully";
char _ininit	szStopFailed[]= "%s: adapter %u, unit %u STOP UNIT failed (%04x)";
char _ininit	szNoStart[]=	"%s: adapter %u, unit %u, cannot issue START UNIT command";
char _ininit	szStartFailed[]="%s: adapter %u, unit %u, START UNIT failed (%04x)";
char _ininit	szTestFailed[]="%s: adapter %u, unit %u, TEST UNIT READY failed (%04x)";
char _ininit	szReadFailed[]="%s: adapter %u, unit %u, READ(6) failed (%04x)";
char _ininit	szStatusblock[]="%s: StatusBlock, Flags %02x, Adapter Error %04x, Target Status %02x";
char _ininit	szAdapterDiag[]="%s: adapter specific info [%s]";
char _ininit	szSensedata[]=	"%s: sense data [%s]";
char _ininit	szHex[]=	"%02x ";
d133 4
a136 4
char _ininit	szCmdLineSyntax[]= "%s: syntax error in command line";
char _ininit	szMissingOption[]= "%s: required option missing in command line";
char _ininit	szUnknownOption[]= "%s: unknown command line option";
char _ininit	szCmdLineError[]="%s: command line option error %d";
d140 2
a141 2
char _ininit	szAvailAPM[]=	"APM is available on this machine!";
char _ininit	szFoundDevice[]="Adapter %u, Unit %u installed (%u min)";
d148 2
a149 2
char _ininit szProduct[]="SCSI Disk Sleeper";
char _ininit szLogo[]=	"\n\r%s                                            Version %u.%02u\n\r" \
d151 2
a152 2
char _ininit szNoReg[]= "Not registered for commercial use";
char _ininit szReg[]=	"Registered to: %s";
d881 2
a882 2
	else if( (ToOption[i].adpno & ~0x80U) == aidx
		&&  ToOption[i].unitno == (UCHAR)uidx )
d922 2
a923 2
	   &&  (ToOption[i].adpno & ~0x80U) == aidx
	   &&  ToOption[i].unitno == (UCHAR)uidx )
d1610 6
@


1.17
log
@- correctly corrected detection of non-SCSI controllers
@
text
@d3 2
a4 2
 * $Revision: 1.16 $
 * $Date: 1997/11/22 01:07:47 $
d13 3
a15 1
static char const id[]="$Id: init1.c,v 1.16 1997/11/22 01:07:47 vitus Exp vitus $";
d34 7
a40 2
#include <dhcalls.h>

d49 18
d182 1
a182 20
USHORT _ininit	usSleepSeconds = SLEEP_TIME;	/* timeout without /[!]UT */




/* Missing in my DDK... */

#define DHGETDOSV_APMINFO	16

#pragma pack(1)
typedef struct _APMINFO {
    USHORT	APM_CodeSeg;
    USHORT	APM_DataSeg;
    USHORT	APM_Offset;
    USHORT	APM_Flags;
    USHORT	APM_Level;
    UCHAR	APM_CPUIdle[6];			/* 32Bit far address */
} APMINFO;
#pragma pack()

a183 19
#if 0 && defined(_MSC_VER)
#pragma optimize("lge",off)
PUBLIC USHORT APIENTRY
DevHelp_Beep(USHORT freq,USHORT ms)
{
    USHORT rc;

    _asm
    {
	mov	bx, freq
	mov	cx, ms
	mov	dl, 0x52
	call	DWORD PTR [Device_Help]
	mov	rc, ax
    }
    return rc;
}
#pragma optimize("",on)
#endif
d257 1
a257 1
PRIVATE void FAR _loadds
d288 3
a290 1
#pragma optimize("lge",off)
d292 1
a292 1
SendIORB(PIORB iorb,void (FAR *addentry)(PIORB))
d294 1
d296 1
d298 1
a298 1
    iorb->NotifyAddress = SendIORBNotify;
d317 3
a319 1
#pragma optimize("",on)
d966 1
a966 1
    void		(FAR *pADDBaseEP)();
d1009 1
a1009 1
	    (PVOID)pADDBaseEP = (PVOID)MAKEP(pDCE->DCSelector, pDCE->DCOffset);
d1046 1
a1046 1
		void	(FAR *pADDEntry)();
d1060 2
a1061 2
		    (PVOID)pADDEntry = (PVOID)MAKEP(pDCEFilter->DCSelector,
						    pDCEFilter->DCOffset);
d1086 1
d1088 1
d1222 1
a1222 1
    {TOK_ID_VERBOSE,	"/V", TYPE_0,		{0,  E,	 E}};
d1225 1
a1225 1
    {TOK_ID_NOT_SR,	"/!SR", TYPE_0,		{0,  E,	 E}};
d1228 1
a1228 1
    {TOK_ID_SR,		"/SR", TYPE_0,		{0,  E,	 E}};
d1231 1
a1231 1
    {TOK_ID_DEBUG,	"/DEBUG", TYPE_0,	{0,  E,	 E}};
d1234 1
a1234 1
    {TOK_ID_DEBUG,	"/DEBUG:", TYPE_D,	{0,  E,	 E}};
d1237 1
a1237 1
    {TOK_ID_TIME,	"/T:", TYPE_DDDD,	{0,  E,	 E}};
d1240 1
a1240 1
    {TOK_ID_NOT_UT,	"/!UT:", TYPE_ULIST,	{0,  E,	 E}};
d1243 1
a1243 1
    {TOK_ID_UT,		"/UT:", TYPE_ULIST,	{0,  E,	 E}};
d1246 1
a1246 1
    {TOK_ID_END,	"\0", TYPE_0,		{O,  O,	 O}};
d1261 9
a1269 9
	(POPT)&OPT_VERBOSE,
	(POPT)&OPT_NSR,
	(POPT)&OPT_SR,
	(POPT)&OPT_DEBUG_NO,
	(POPT)&OPT_DEBUG_DEFAULT,
	(POPT)&OPT_TIME,
	(POPT)&OPT_NUT,
	(POPT)&OPT_UT,
	(POPT)&OPT_END
d1293 1
a1293 1
    PCHAR	cp;
d1295 1
a1295 1
    CHAR	TokenId;
d1349 2
a1350 2
	(TokenId=*(cp+TOKL_ID)) != TOK_ID_END;
	cp += *(cp+TOKL_LEN) )
d1520 1
a1520 2

    CHAR _based((_segment)pInitParms)	*bpCmdLine;
d1527 1
a1527 1
    bpCmdLine	= (CHAR _based((_segment)pInitParms) *)pInitParms->cmd_line_args;
d1535 1
a1535 1
    AnalyseCmdLine((PSZ)bpCmdLine);
d1611 3
@


1.16
log
@- corrected detection of non-SCSI controllers
@
text
@d3 2
a4 2
 * $Revision: 1.15 $
 * $Date: 1997/10/26 00:29:18 $
d13 1
a13 1
static char const id[]="$Id: init1.c,v 1.15 1997/10/26 00:29:18 vitus Exp vitus $";
d78 1
a78 1
char _ininit	szNoSCSI[]=	"%s: adapter %u has no SCSI bus";
d446 2
d461 2
a462 3
    if( !(npAdapterInfo->AdapterDevBus == AI_DEVBUS_SCSI_1
	  ||  npAdapterInfo->AdapterDevBus == AI_DEVBUS_SCSI_2
	  ||  npAdapterInfo->AdapterDevBus == AI_DEVBUS_SCSI_3) )
d469 2
a470 1
	    sprintk(szMsgBuffer, szNoSCSI, (PSZ)szDriverName, iAdapter);
d1617 3
@


1.15
log
@- longer and higher beep
- /!UT device aren't tested
- modified UnitHandle is pointer not index (better debugging)
@
text
@d3 2
a4 2
 * $Revision: 1.14 $
 * $Date: 1997/10/24 23:30:58 $
d13 1
a13 1
static char const id[]="$Id: init1.c,v 1.14 1997/10/24 23:30:58 vitus Exp vitus $";
d459 3
a461 3
    if( !((npAdapterInfo->AdapterDevBus & AI_DEVBUS_SCSI_1)
	  ||  (npAdapterInfo->AdapterDevBus & AI_DEVBUS_SCSI_2)
	  ||  (npAdapterInfo->AdapterDevBus & AI_DEVBUS_SCSI_3)) )
d1615 5
@


1.14
log
@- slower beep (lo ger)
@
text
@d3 2
a4 2
 * $Revision: 1.13 $
 * $Date: 1997/10/11 17:44:11 $
d13 1
a13 1
static char const id[]="$Id: init1.c,v 1.13 1997/10/11 17:44:11 vitus Exp vitus $";
d275 1
a275 1
    DevHelp_ProcRun( (ULONG)iorb, &awoken );
d369 1
a369 1
	DevHelp_Beep(20000, 2000);		/* wait some time */
d384 1
a384 1
    DevHelp_Beep(20000, 1000);			/* wait some time */
d401 1
a401 1
	DevHelp_Beep(20000, 2000);		/* wait some time */
d623 3
a625 1
     * without a registered driver. */
d627 1
a627 1
    if( (fDriverFlags & DF_TESTOP) )
d1094 1
a1094 1
		anpUnit[cUnit]->modinfo.UnitHandle = cUnit;
d1156 1
a1156 1
	    RemoveFilter( anpUnit[i] );
d1198 1
a1198 1
	sprintk( szMsgBuffer, szNoTimer, (PSZ)szDriverName );
d1304 2
a1305 2
    parse_rc = Command_Parser( pszLine, &opttable,
			      DeviceTable, MAX_DEVICETABLE_SIZE );
d1318 1
a1318 1
	sprintk( szMsgBuffer, szCmdLineSyntax, (PSZ)szDriverName );
d1326 1
a1326 1
	sprintk( szMsgBuffer, szMissingOption, (PSZ)szDriverName );
d1334 2
a1335 2
	sprintk( szMsgBuffer, szUnknownOption,
		(PSZ)szDriverName, (PBYTE)DeviceTable );
d1343 2
a1344 2
	sprintk( szMsgBuffer, szCmdLineError,
		(PSZ)szDriverName, parse_rc.ret_code );
d1384 2
a1385 2
		    sprintk( szMsgBuffer, szUnknownOption,
			    (PSZ)szDriverName, (PBYTE)DeviceTable );
d1402 2
a1403 3
		Add2TOTable( *(PUSHORT)(cp+TOKL_VALUE+i),
			    *(PUSHORT)(cp+TOKL_VALUE+i+2),
			    time );
d1414 1
a1414 1
		    sprintk( szMsgBuffer, szCmdLineSyntax, (PSZ)szDriverName );
d1418 1
a1418 1
		    Add2TOTable( *(PUSHORT)(cp+TOKL_VALUE+i),
d1420 1
a1420 1
				0 );
d1471 1
a1471 1
    _far_memset( code, 0, REG_KEYLEN );
d1539 1
a1539 1
    AnalyseCmdLine( (PSZ)bpCmdLine );
d1547 1
a1547 1
	sprintk( szMsgBuffer, szLogo, (PSZ)szProduct, VERSION, SUBVERSION );
d1551 1
a1551 1
	    sprintk( szMsgBuffer, szReg, (PSZ)RegData.szUser );
d1556 1
a1556 1
	    sprintk( szMsgBuffer, szNoReg );
d1615 3
@


1.13
log
@- does driver registration *after* device test
- clear IORB with MAX_IORB_SIZE bytes, as most DMD do
@
text
@d3 3
a5 3
 * $Revision: 1.12 $
 * $Date: 1997/09/03 01:02:23 $
 * $Locker$
d13 1
a13 1
static char const id[]="$Id: init1.c,v 1.12 1997/09/03 01:02:23 vitus Exp vitus $";
d369 1
a369 1
	DevHelp_Beep(20000, 500);		/* wait some time */
d384 1
a384 1
    DevHelp_Beep(20000, 500);			/* wait some time */
d401 1
a401 1
	DevHelp_Beep(20000, 500);		/* wait some time */
d1614 4
@


1.12
log
@Saves status and sense values in device structure (IOCtl retrieves)
Accept /!DM or /!SM units
@
text
@d3 3
a5 3
 * $Revision: 1.11 $
 * $Date: 1997/07/21 01:13:38 $
 * $Author: vitus $
d9 3
a11 49
 * $Log: init1.c,v $
 * Revision 1.11  1997/07/21 01:13:38  vitus
 * Changed TestOperation to use IssueStart,IssueStop
 * Added /SR, /!SR tokens in AnalyseCmdLine
 * Detects APM
 *
 * Revision 1.10  1997/06/18 00:49:45  vitus
 * SendIORB() now saves,restores all registers
 *
 * Revision 1.9  1997/06/03 23:44:11  vitus
 * Removed syntax errors
 *
 * Revision 1.8  1997/05/11 14:44:12  vitus
 * Removed TAB from logo string
 *
 * Revision 1.7  1997/05/07 23:31:37  vitus
 * Added DEBMSG calls and strings
 * Devhelp_Beep now public (see iorb.c)
 * Corrected dump of status block
 * Delayed driver registration (avoids trap)
 * Shows timeout on unit display
 * Resident memory area expanded to next paragraph
 *
 * Revision 1.6	 1997/03/03 01:15:02  vitus
 * Corrected dump of sense bytes
 * Corrected adapter numbering
 * Uses SaveMessage instead of DevHelp_Save_Message
 *
 * Revision 1.5	 1997/02/06 01:08:59  vitus
 * Changed copyright to 1997 and 2:2474/424
 *
 * Revision 1.4	 1996/11/04 00:14:57  vitus
 * Better TestOperation(), corrected error display
 * Displays missing 16MB, HW S/G support (debug)
 * Parses /[!]UT tokens (timeout per device)
 *
 * Revision 1.3	 1996/10/24 00:12:25  vitus
 * Added registration check/display
 * Modularisiert
 * Added /Debug[:1] switch
 * Tests start/stop
 *
 * Revision 1.2	 1996/09/30 00:27:21  vitus
 * Added command line parsing
 *
 * Revision 1.1	 1996/09/27 02:28:09  vitus
 * Initial revision
 * ----------------------------------------
 * This code is Copyright Vitus Jensen 1996
d13 1
a13 1
static char const id[]="$Id: init1.c,v 1.11 1997/07/21 01:13:38 vitus Exp vitus $";
d178 1
a178 1
#if defined(_MSC_VER)
d216 1
a216 1
    sprintk( szMsgBuffer, szStatusblock, (PSZ)szDriverName,
d218 1
a218 1
	    statusblock->TargetStatus );
d231 1
a231 1
	sprintk( szMsgBuffer, szAdapterDiag, (PSZ)szDriverName, (PSZ)achDump );
a241 1

d299 1
a299 1
 *	after add call.
d305 1
a305 1
    ULONG	dummy;
a553 15
#if 0
    /* Really neccessary to restrict that way? */

    if( (uflags & UF_NODASD_SUPT)  &&  (uflags & UF_NOSCSI_SUPT) )
    {
	if( (fDriverFlags & DF_DEBUG) )
	{
	    sprintk(szMsgBuffer, szNoSupport, (PSZ)szDriverName,
		    iAdapter, npUnitInfo->UnitIndex);
	    SaveMessage();
	}
	return 5;
    }
#endif

d565 1
d568 1
d571 2
d574 2
d581 1
d583 3
a592 24
    if( (fDriverFlags & DF_REGDEVCLASS) == 0 )
    {
	BOOL	bool;

	/* Do late registration of this filter driver.
	 * A registered driver returning 'don't install' will
	 * panic the kernel. :-( */

	DEBMSG(dszRegister);
	bool = DevHelp_RegisterDeviceClass( (NPSZ)szDriverName,
					   (PFN)FilterFunction,
					   (USHORT)DRIVERFLAGS,
					   (USHORT)DRIVERCLASS_ADD,
					   (PUSHORT)&hdThisDriver );
	if( bool )
	{
	    sprintk(szMsgBuffer, szRegDevClassFailed, (PSZ)szDriverName);
	    SaveMessage();
	    return -1;
	}
	fDriverFlags |= DF_REGDEVCLASS;		/* done! */
    }

    /* Insert late-breaking-news in device structure */
d594 2
a595 1
    npDevice->modinfo.FilterADDHandle = hdThisDriver;
d601 1
a601 3
	/* Send request to ALLOCATE UNIT */

	memset(pIOUC, 0, sizeof(IORB_UNIT_CONTROL));
d621 4
d628 1
a628 1
	    rc = -1;
d631 29
a664 1
	/* Send request to CHANGE UNITINFO */
d666 6
a671 1
	memset(pIOUC, 0, sizeof(IORB_UNIT_CONTROL));
d693 1
a693 1
	    rc = 2;
d703 1
a703 1
	memset( pIOUC, 0, sizeof(IORB_UNIT_CONTROL) );
d720 1
a720 2
		    (PSZ)szDriverName,
		    npDevice->iAdapter, npDevice->iUnit);
d761 1
a761 1
	memset( pIOUC, 0, sizeof(IORB_UNIT_CONTROL) );
d792 1
a792 1
	memset( pIOUC, 0, sizeof(IORB_UNIT_CONTROL) );
d824 1
a824 1
	memset( pIOUC, 0, sizeof(IORB_UNIT_CONTROL) );
d1003 1
a1003 1
	    memset(pIOCF, 0, sizeof(IORB_CONFIGURATION));
d1608 57
@


1.11
log
@Changed TestOperation to use IssueStart,IssueStop
Added /SR, /!SR tokens in AnalyseCmdLine
Detects APM
@
text
@d3 2
a4 2
 * $Revision: 1.10 $
 * $Date: 1997/06/18 00:49:45 $
d10 5
d16 1
a16 1
 * - SendIORB() now saves,restores all registers
d19 1
a19 1
 * - removed syntax errors
d22 1
a22 1
 * - removed TAB from logo string
d25 6
a30 6
 * - added DEBMSG calls and strings
 * - DevHelp_Beep now public (see iorb.c)
 * - corrected dump of status block
 * - delayed driver registration (avoids trap)
 * - shows timeout on unit display
 * - resident memory area expanded to next paragraph
d59 1
a59 1
static char const id[]="$Id: init1.c,v 1.10 1997/06/18 00:49:45 vitus Exp vitus $";
d83 1
d341 1
a341 1
 *	none
d366 1
a366 1
	DevHelp_ProcBlock( (ULONG)iorb, -1L, WAIT_IS_NOT_INTERRUPTABLE );
d601 4
a604 1
    if( (uflags & (UF_NODASD_SUPT | UF_NOSCSI_SUPT)) )
d614 1
d674 1
a674 1

d678 1
a678 1
	memset( pIOUC, 0, sizeof(IORB_UNIT_CONTROL) );
d684 6
a689 1
	if( SendIORB((PIORB)pIOUC, npDevice->pADDEntry) )
d691 2
a692 3
	    sprintk(szMsgBuffer, szAllocFailed,
		    (PSZ)szDriverName, npDevice->iAdapter,
		    npDevice->iUnit);
d707 1
d720 6
a725 1
	if( SendIORB((PIORB)pIOUC, npDevice->pADDEntry) )
d739 1
d749 6
a754 1
	if( SendIORB((PIORB)pIOUC, npDevice->pADDEntry) )
d798 1
a798 1

d808 6
a813 1
	if( SendIORB((PIORB)pIOUC, npDevice->pADDEntry) )
d829 1
d842 6
a847 1
	if( SendIORB((PIORB)pIOUC, npDevice->pADDEntry) )
d861 1
d871 6
a876 1
	if( SendIORB((PIORB)pIOUC, npDevice->pADDEntry) )
d1044 1
a1044 1
	    memset( pIOCF, 0, sizeof(IORB_CONFIGURATION) );
@


1.10
log
@- SendIORB() now saves,restores all registers
@
text
@d3 2
a4 2
 * $Revision: 1.9 $
 * $Date: 1997/06/03 23:44:11 $
d10 3
a50 1
 *
d54 1
a54 1
static char const id[]="$Id: init1.c,v 1.9 1997/06/03 23:44:11 vitus Exp vitus $";
d138 1
d154 1
d156 1
d160 1
d187 1
d203 15
d395 1
a395 10
    NPIORB_ADAPTER_PASSTHRU	iothru = (NPVOID)device->iorb;
    NPIORB_EXECUTEIO		ioexec = (NPVOID)device->iorb;
    NPSCSI_STATUS_BLOCK const	statusblock = (NPVOID)npInitData;
    NPSCSI_REQSENSE_DATA const	sensedata = (NPVOID)(npInitData + sizeof(SCSI_STATUS_BLOCK));
    NPBYTE const	readdata = (NPBYTE)sensedata + sizeof(SCSI_REQSENSE_DATA);

    BYTE		cdb[6];			/* need 6byte TEST UNIT READY */
    USHORT		error;
    int			retries;

d404 4
a407 13
    memset( iothru, 0, sizeof(IORB_ADAPTER_PASSTHRU) );
    memset( statusblock, 0, sizeof(SCSI_STATUS_BLOCK) );
    statusblock->ReqSenseLen = sizeof(SCSI_REQSENSE_DATA);
    statusblock->SenseData = sensedata;

    iothru->iorbh.Length =		sizeof(IORB_ADAPTER_PASSTHRU);
    iothru->iorbh.UnitHandle =		device->hdADDUnit;
    iothru->iorbh.CommandCode =		IOCC_ADAPTER_PASSTHRU;
    iothru->iorbh.CommandModifier =	IOCM_EXECUTE_CDB;

    iothru->iorbh.RequestControl =	IORB_REQ_STATUSBLOCK;
    iothru->iorbh.StatusBlockLen =	sizeof(SCSI_STATUS_BLOCK);
    iothru->iorbh.pStatusBlock =		(NPBYTE)statusblock;
d409 2
a410 2
    iothru->pControllerCmd =		device->cdbStop;
    iothru->ControllerCmdLen =		6;
d412 1
a412 1
    if( (error=SendIORB((PIORB)iothru, device->pADDEntry)) != 0 )
d414 2
a415 2
	sprintk(szMsgBuffer, szStopFailed,
		(PSZ)szDriverName, device->iAdapter, device->iUnit, error);
d417 2
a418 2
	DumpStatusblock( statusblock );
	return 1;
d425 1
a425 1
    /* Second: device should also be restartable... */
a426 13
    memset( iothru, 0, sizeof(IORB_ADAPTER_PASSTHRU) );
    memset( statusblock, 0, sizeof(SCSI_STATUS_BLOCK) );
    statusblock->ReqSenseLen = sizeof(SCSI_REQSENSE_DATA);
    statusblock->SenseData = sensedata;

    iothru->iorbh.Length =		sizeof(IORB_ADAPTER_PASSTHRU);
    iothru->iorbh.UnitHandle =		device->hdADDUnit;
    iothru->iorbh.CommandCode =		IOCC_ADAPTER_PASSTHRU;
    iothru->iorbh.CommandModifier =	IOCM_EXECUTE_CDB;

    iothru->iorbh.RequestControl =	IORB_REQ_STATUSBLOCK;
    iothru->iorbh.StatusBlockLen =	sizeof(SCSI_STATUS_BLOCK);
    iothru->iorbh.pStatusBlock =		(NPBYTE)statusblock;
d428 1
a428 2
    iothru->pControllerCmd =		device->cdbStart;
    iothru->ControllerCmdLen =		6;
d430 2
a431 1
    if( (error=SendIORB((PIORB)iothru, device->pADDEntry)) != 0 )
d433 2
a434 2
	sprintk(szMsgBuffer, szStartFailed,
		(PSZ)szDriverName, device->iAdapter, device->iUnit, error);
d436 1
a436 43
	DumpStatusblock( statusblock );
	return 2;
    }


    /* Third: is this device functional again?
     * Use TEST UNIT READY to detect and allow some retries (first
     * call should return CHECK CONDITION). */

    retries = 6;
    do
    {
	memset( iothru, 0, sizeof(IORB_ADAPTER_PASSTHRU) );
	memset( statusblock, 0, sizeof(SCSI_STATUS_BLOCK) );
	statusblock->ReqSenseLen = sizeof(SCSI_REQSENSE_DATA);
	statusblock->SenseData = sensedata;

	_far_memset( cdb, 0, 6 );		/* opcode is 0, too! */

	cdb[1] = device->cdbStart[1];		/* copy LUN */

	iothru->iorbh.Length =		sizeof(IORB_ADAPTER_PASSTHRU);
	iothru->iorbh.UnitHandle =	device->hdADDUnit;
	iothru->iorbh.CommandCode =	IOCC_ADAPTER_PASSTHRU;
	iothru->iorbh.CommandModifier = IOCM_EXECUTE_CDB;

	iothru->iorbh.RequestControl =	IORB_REQ_STATUSBLOCK;
	iothru->iorbh.StatusBlockLen =	sizeof(SCSI_STATUS_BLOCK);
	iothru->iorbh.pStatusBlock =	(NPBYTE)statusblock;

	iothru->pControllerCmd =		cdb;
	iothru->ControllerCmdLen =	6;

	error = SendIORB( (PIORB)iothru, device->pADDEntry );
	if( error == 0 )
	    break;

	sprintk(szMsgBuffer, szTestFailed,
		(PSZ)szDriverName, device->iAdapter, device->iUnit, error);
	SaveMessage();
	DumpStatusblock( statusblock );

	DevHelp_Beep( 20000, 50 );		/* wait some time */
a437 4
    while( retries-- );
    if( error != 0 )
	return 3;

d439 1
a439 1
    /* Fourth: test device operation by reading a sector */
d441 2
a442 18
    memset( ioexec, 0, sizeof(IORB_EXECUTEIO) );
    memset( statusblock, 0, sizeof(SCSI_STATUS_BLOCK) );
    statusblock->ReqSenseLen = sizeof(SCSI_REQSENSE_DATA);
    statusblock->SenseData = sensedata;

    ioexec->iorbh.Length =		sizeof(IORB_EXECUTEIO);
    ioexec->iorbh.UnitHandle =		device->hdADDUnit;
    ioexec->iorbh.CommandCode =		IOCC_EXECUTE_IO;
    ioexec->iorbh.CommandModifier =	IOCM_READ_VERIFY;

    ioexec->iorbh.RequestControl =	IORB_REQ_STATUSBLOCK;
    ioexec->iorbh.StatusBlockLen =	sizeof(SCSI_STATUS_BLOCK);
    ioexec->iorbh.pStatusBlock =	(NPBYTE)statusblock;

    ioexec->RBA = 0;			/* any sector number */
    ioexec->BlockCount = 1;		/* verify single sector */
    ioexec->BlockSize = 512;		/* assume normal disk */
    ioexec->Flags = XIO_DISABLE_HW_READ_CACHE; /* if supported */
d444 1
a444 1
    if( (error=SendIORB((PIORB)ioexec, device->pADDEntry)) != 0 )
d446 2
a447 2
	sprintk(szMsgBuffer, szReadFailed,
		(PSZ)szDriverName, device->iAdapter, device->iUnit, error);
d449 1
a449 1
	DumpStatusblock( statusblock );
d1223 6
d1257 2
a1258 3
OPTIONTABLE  opttable =

{   ENTRY_STATE, MAX_STATES,
d1260 9
a1268 7
     (POPT) &OPT_VERBOSE,
     (POPT) &OPT_DEBUG_NO,
     (POPT) &OPT_DEBUG_DEFAULT,
     (POPT) &OPT_TIME,
     (POPT) &OPT_NUT,
     (POPT) &OPT_UT,
     (POPT) &OPT_END
d1357 8
d1515 3
a1517 2
    PULONG	pInfoSegSel;
    int		rc;
a1529 1

d1556 13
@


1.9
log
@- removed syntax errors
@
text
@d3 2
a4 2
 * $Revision: 1.8 $
 * $Date: 1997/05/11 14:44:12 $
d10 3
d52 1
a52 1
static char const id[]="$Id: init1.c,v 1.8 1997/05/11 14:44:12 vitus Exp vitus $";
d317 2
d324 2
d331 3
a333 1
    (addentry)( iorb );
@


1.8
log
@- removed TAB from logo string
@
text
@d3 2
a4 2
 * $Revision: 1.7 $
 * $Date: 1997/05/07 23:31:37 $
d10 3
d49 1
a49 1
static char const id[]="$Id: init1.c,v 1.7 1997/05/07 23:31:37 vitus Exp vitus $";
d89 1
a89 1
char _inconst	dszRegister[]=		"\r\nRegistrating device class";
d125 1
a125 1
char _ininit	szRegDevClassFailed[]=	"%s: error registrating device class";
d158 2
a159 2
char _ininit szNoReg[]= "Not registrated for commercial usage";
char _ininit szReg[]=	"Registrated to: %s";
d359 1
a359 1
 *	we to a READ_VERIFY.  Hopefully this affects the medium, too.
d702 1
a702 1
	 * A registrated driver returning 'don't install' will
d1112 1
a1112 1
		/* If a Filter ADD has registered for this unit
d1503 1
a1503 1
 *	Sets DF_REGISTRATION in fDriverFlags depending on
d1526 1
a1526 1
	fDriverFlags |= DF_REGISTRATED;
d1587 1
a1587 1
    if( !(fDriverFlags & DF_REGISTRATED) )
d1593 1
a1593 1
	if( (fDriverFlags & DF_REGISTRATED) )
@


1.7
log
@- added DEBMSG calls and strings
- DevHelp_Beep now public (see iorb.c)
- corrected dump of status block
- delayed driver registration (avoids trap)
- shows timeout on unit display
- resident memory area expanded to next paragraph
@
text
@d3 2
a4 2
 * $Revision: 1.6 $
 * $Date: 1997/03/03 01:15:02 $
d10 8
d46 1
a46 1
static char const id[]="$Id: init1.c,v 1.6 1997/03/03 01:15:02 vitus Exp vitus $";
d153 1
a153 1
char _ininit szLogo[]=	"\n\r%s	                                           Version %u.%02u\n\r" \
@


1.6
log
@Corrected dump of sense bytes
Corrected adapter numbering
Uses SaveMessage instead of DevHelp_Save_Message
@
text
@d3 2
a4 2
 * $Revision: 1.5 $
 * $Date: 1997/02/06 01:08:59 $
d10 6
a15 1
 * Revision 1.5  1997/02/06 01:08:59  vitus
d18 1
a18 1
 * Revision 1.4  1996/11/04 00:14:57  vitus
d23 1
a23 1
 * Revision 1.3  1996/10/24 00:12:25  vitus
d29 1
a29 1
 * Revision 1.2  1996/09/30 00:27:21  vitus
d32 1
a32 1
 * Revision 1.1  1996/09/27 02:28:09  vitus
d38 1
a38 2
static char vcid[]="$Id: init1.c,v 1.5 1997/02/06 01:08:59 vitus Exp vitus $";

a41 1
//#define INCL_NOBASEAPI
d72 28
a99 3
/*
 * Messages used during initialization
 */
d105 1
a105 1
char _ininit	szNoDiskType[]=	"%s: adapter %u, unit %u is no disk device";
d121 1
a121 1
char _ininit	szStopFailed[]=	"%s: adapter %u, unit %u STOP UNIT failed (%04x)";
d138 1
a138 1
char _ininit	szFoundDevice[]="Adapter %u, Unit %u installed";
d145 1
a145 1
char _ininit szLogo[]=	"\n\r%s                                            Version %u.%02u\n\r" \
d147 1
a147 1
char _ininit szNoReg[]=	"Not registrated for commercial usage";
d162 1
a162 1
    "\00023456789012345678901234567890123456789",
a180 7
/*
 * Last element in code segments which remains resident
 */
PRIVATE void
Code_End(void) {}


d184 1
a184 1
PRIVATE USHORT APIENTRY
d193 1
a193 1
	mov	dl, 52
d205 9
d215 1
a215 1
PRIVATE void
a217 2
    PSCSI_REQSENSE_DATA	sensedata = statusblock->SenseData;

d244 2
d249 2
a250 3
	    sprintk(&achDump[_far_strlen(achDump)],
		    szHex, statusblock->SenseData[i]);
	sprintk( szMsgBuffer, szSensedata, (PSZ)szDriverName, (PSZ)achDump );
d305 1
a305 1
PRIVATE USHORT
d350 1
a350 1
PRIVATE int
d388 1
a388 1
    if( (error=SendIORB((PIORB)iothru, device->pADDEntry)) )
d420 1
a420 1
    if( (error=SendIORB((PIORB)iothru, device->pADDEntry)) )
d449 1
a449 1
	iothru->iorbh.CommandModifier =	IOCM_EXECUTE_CDB;
d495 1
a495 1
    if( (error=SendIORB((PIORB)ioexec, device->pADDEntry)) )
d535 1
a535 1
PRIVATE int
d595 1
a595 1
PRIVATE int
d685 28
d747 1
a747 1
	memset( pIOUC, 0, sizeof(IORB_UNIT_CONTROL) );
d791 1
d804 1
d806 2
d809 1
d811 2
d820 1
d917 1
a917 1
PRIVATE void
d964 2
a965 2
PRIVATE TO_OPTION FAR *
QueryTOTable(USHORT aidx,USHORT uidx)
d1010 1
a1010 1
PRIVATE int
a1016 1
    USHORT	FilterADDHandle;
a1017 1
    void		(FAR *pADDEntry)();
d1020 1
a1020 1
    struct DevClassTableEntry FAR *pDCE, FAR *pDCEFilter;
d1024 2
d1030 1
a1030 1
	/* Should never happen.  What can we do? */
d1040 1
a1040 1
    /* For each ADD registered  */
d1042 1
d1066 1
a1066 1
		 * ADD.  Just ignore that ADD (which probably hasn't
d1078 1
d1082 1
a1082 1
        {
d1093 1
d1097 3
a1099 1
            {
d1105 5
a1109 2
		if( FilterADDHandle = npUnitInfo->FilterADDHandle )
                {
d1112 3
a1114 3
		    (PVOID)pADDEntry = (PVOID)MAKEP( pDCEFilter->DCSelector,
						    pDCEFilter->DCOffset );
                }
d1116 1
a1116 1
                {
d1118 1
a1118 1
                }
a1122 7
		if( (fDriverFlags & DF_VERBOSE) )
		{
		    sprintk(szMsgBuffer, szFoundDevice,
			    adapter_index, npUnitInfo->UnitIndex);
		    SaveMessage();
		}

d1126 1
a1126 1
		 * Needed:
d1131 2
a1132 1
		memset( anpUnit[cUnit], 0, sizeof(DEVICE) );
a1140 1
		anpUnit[cUnit]->modinfo.FilterADDHandle = hdThisDriver;
d1168 1
a1168 1
		    /* Couldn't allocate unit.  Release
d1178 8
d1191 1
d1197 1
a1197 1
	 * install this driver.  But there may be devices where
d1210 1
a1210 1
	    sprintk( szMsgBuffer, szNoDevices, (PSZ)szDriverName );
d1238 1
a1238 1
PRIVATE int
d1241 2
a1242 1
    if( DevHelp_TickCount((NPFN)&AsmTimer, 
d1272 1
a1272 1
    {TOK_ID_VERBOSE,	"/V", TYPE_0,		{0,  E,  E}};
d1275 1
a1275 1
    {TOK_ID_DEBUG,	"/DEBUG", TYPE_0,	{0,  E,  E}};
d1278 1
a1278 1
    {TOK_ID_DEBUG,	"/DEBUG:", TYPE_D,	{0,  E,  E}};
d1281 1
a1281 1
    {TOK_ID_TIME,	"/T:", TYPE_DDDD,	{0,  E,  E}};
d1284 1
a1284 1
    {TOK_ID_NOT_UT,	"/!UT:", TYPE_ULIST,	{0,  E,  E}};
d1287 1
a1287 1
    {TOK_ID_UT,		"/UT:", TYPE_ULIST,	{0,  E,  E}};
d1290 1
a1290 1
    {TOK_ID_END,	"\0", TYPE_0,		{O,  O,  O}};
d1374 1
a1374 1
	sprintk( szMsgBuffer, szUnknownOption, 
d1383 1
a1383 1
	sprintk( szMsgBuffer, szCmdLineError, 
d1391 2
a1392 2
    for( cp = DeviceTable; 
	(TokenId=*(cp+TOKL_ID)) != TOK_ID_END; 
d1416 1
a1416 1
		    sprintk( szMsgBuffer, szUnknownOption, 
d1469 1
a1469 3
#if __DEBUG__
	    _asm int 3;
#endif
d1482 1
d1484 1
d1486 1
d1488 1
d1490 1
d1496 1
a1496 1
PRIVATE void
d1514 1
a1514 1
    if( i != 0  &&  _far_memcmp(code, RegData.szRegCode, i) == 0 )
d1548 1
a1548 1
PUBLIC USHORT
d1553 2
a1554 2
    BOOL	bool;
    PRPINITOUT	pRPO = (PRPINITOUT)pRPI;
a1555 1
    PDDD_PARM_LIST			pInitParms;
d1558 1
a1558 3
#if defined(DEBUG)
    _asm{ int 3 }
#endif
a1562 1
    pInitParms	= (PDDD_PARM_LIST)pRPI->InitArgs;
d1594 2
a1595 12
    bool = DevHelp_RegisterDeviceClass( (NPSZ)szDriverName,
				       (PFN)FilterFunction,
				       (USHORT)DRIVERFLAGS,
				       (USHORT)DRIVERCLASS_ADD,
				       (PUSHORT)&hdThisDriver );
    if( bool )
    {
	sprintk( szMsgBuffer, szRegDevClassFailed, (PSZ)szDriverName );
	SaveMessage();
	rc = -1;
    }
    else
d1597 1
a1597 6
	rc = ScanDevices();

	if( rc == 0 )
	{
	    rc = InstallTimer();
	}
d1608 3
a1610 3
	pRPO->Unit    = 0;
	pRPO->CodeEnd = (USHORT)Code_End;
	pRPO->DataEnd = (USHORT)npInitData;
d1612 1
d1618 1
a1618 1
	pRPO->Unit    = 0;
d1622 1
@


1.5
log
@Changed copyright to 1997 and 2:2474/424
@
text
@d3 2
a4 2
 * $Revision: 1.4 $
 * $Date: 1996/11/04 00:14:57 $
d10 3
d33 1
a33 1
static char vcid[]="$Id: init1.c,v 1.4 1996/11/04 00:14:57 vitus Exp vitus $";
d195 1
a195 1
    DevHelp_Save_Message( (NPBYTE)&msgBuffer );
d205 2
a206 2
	    sprintk( &achDump[strlen(achDump)],
		    szHex, statusblock->AdapterDiagInfo[i] );
d208 1
a208 1
	DevHelp_Save_Message( (NPBYTE)&msgBuffer );
d219 2
a220 1
	    sprintk(&achDump[strlen(achDump)], szHex, statusblock->SenseData[i]);
d222 1
a222 1
	DevHelp_Save_Message( (NPBYTE)&msgBuffer );
d305 1
a305 1
 *	TestOperation(device,aidx,uidx)
a307 1
 *	aidx,uidx	used to display coordinates
d322 1
a322 1
TestOperation(NPDEVICE const device,USHORT const aidx,USHORT const uidx)
d335 3
a337 2
    sprintk( szMsgBuffer, szTestStart, (PSZ)szDriverName, aidx, uidx );
    DevHelp_Save_Message( (NPBYTE)&msgBuffer );
d361 3
a363 3
	sprintk( szMsgBuffer, szStopFailed,
		(PSZ)szDriverName, aidx, uidx, error );
	DevHelp_Save_Message( (NPBYTE)&msgBuffer );
d393 3
a395 3
	sprintk( szMsgBuffer, szStartFailed,
		(PSZ)szDriverName, aidx, uidx, error );
	DevHelp_Save_Message( (NPBYTE)&msgBuffer );
d433 3
a435 3
	sprintk( szMsgBuffer, szTestFailed,
		(PSZ)szDriverName, aidx, uidx, error );
	DevHelp_Save_Message( (NPBYTE)&msgBuffer );
d468 3
a470 3
	sprintk( szMsgBuffer, szReadFailed,
		(PSZ)szDriverName, aidx, uidx, error );
	DevHelp_Save_Message( (NPBYTE)&msgBuffer );
d479 3
a481 2
    sprintk( szMsgBuffer, szTestComplete, (PSZ)szDriverName, aidx, uidx );
    DevHelp_Save_Message( (NPBYTE)&msgBuffer );
d483 1
a483 1
}
d490 1
d492 1
d494 2
d497 2
d500 1
d502 2
d507 1
a507 1
CheckAdapterInfo(USHORT const add_index,NPADAPTERINFO const npAdapterInfo)
d512 2
a513 2
	sprintk( szMsgBuffer, szNo16M, (PSZ)szDriverName, add_index );
	DevHelp_Save_Message( (NPBYTE)&msgBuffer );
d518 2
a519 2
	sprintk( szMsgBuffer, szNoScGa, (PSZ)szDriverName, add_index );
	DevHelp_Save_Message( (NPBYTE)&msgBuffer );
d531 2
a532 2
	    sprintk( szMsgBuffer, szNoSCSI, (PSZ)szDriverName, add_index );
	    DevHelp_Save_Message( (NPBYTE)&msgBuffer );
d538 1
a538 1
}
d545 1
d547 1
d549 2
d552 2
a553 2
 *	0	OK, try/use this unit
 *	/0	bad type, defective, etc.
d555 1
d567 1
a567 1
CheckUnitInfo(USHORT const add_index,NPUNITINFO const npUnitInfo)
d577 3
a579 3
	    sprintk( szMsgBuffer, szNoDiskType, (PSZ)szDriverName,
		    add_index, npUnitInfo->UnitIndex );
	    DevHelp_Save_Message( (NPBYTE)&msgBuffer );
d588 3
a590 3
	    sprintk( szMsgBuffer, szRemovable, (PSZ)szDriverName,
		    add_index, npUnitInfo->UnitIndex );
	    DevHelp_Save_Message( (NPBYTE)&msgBuffer );
d599 3
a601 3
	    sprintk( szMsgBuffer, szDiskette, (PSZ)szDriverName,
		    add_index, npUnitInfo->UnitIndex );
	    DevHelp_Save_Message( (NPBYTE)&msgBuffer );
d610 3
a612 3
	    sprintk( szMsgBuffer, szDefective, (PSZ)szDriverName,
		    add_index, npUnitInfo->UnitIndex );
	    DevHelp_Save_Message( (NPBYTE)&msgBuffer );
d621 3
a623 3
	    sprintk( szMsgBuffer, szNoSupport, (PSZ)szDriverName,
		    add_index, npUnitInfo->UnitIndex );
	    DevHelp_Save_Message( (NPBYTE)&msgBuffer );
d629 1
a629 1
}
d634 1
a634 1
/*
d636 1
d638 1
d640 1
d642 1
d652 1
a652 1
InstallFilter(NPDEVICE const npDevice,USHORT const aidx,USHORT const uidx)
d670 4
a673 3
	    sprintk( szMsgBuffer, szAllocFailed,
		    (PSZ)szDriverName, aidx, uidx );
	    DevHelp_Save_Message( (NPBYTE)&msgBuffer );
d680 1
a680 1
	if( TestOperation(npDevice, aidx, uidx) )
d701 3
a703 3
	    sprintk( szMsgBuffer, szChangeUInfoFailed,
		    (PSZ)szDriverName, aidx, uidx );
	    DevHelp_Save_Message( (NPBYTE)&msgBuffer );
d727 4
a730 3
	    sprintk( szMsgBuffer, szDeallocFailed,
		    (PSZ)szDriverName, aidx, uidx );
	    DevHelp_Save_Message( (NPBYTE)&msgBuffer );
d735 1
a735 1
}
d742 1
d744 1
d770 3
a772 3
	    sprintk( szMsgBuffer, szAllocFailed,
		    (PSZ)szDriverName, -1, npDevice->modinfo.UnitIndex );
	    DevHelp_Save_Message( (NPBYTE)&msgBuffer );
d798 3
a800 3
	    sprintk( szMsgBuffer, szChangeUInfoFailed,
		    (PSZ)szDriverName, -1, npDevice->modinfo.UnitIndex );
	    DevHelp_Save_Message( (NPBYTE)&msgBuffer );
d824 3
a826 3
	    sprintk( szMsgBuffer, szDeallocFailed,
		    (PSZ)szDriverName, -1, npDevice->modinfo.UnitIndex );
	    DevHelp_Save_Message( (NPBYTE)&msgBuffer );
d831 1
a831 1
}
d838 1
d840 1
d842 2
d845 1
d847 1
d853 1
a853 1
Add2TOTable(USHORT aidx,USHORT uidx,USHORT to)
d885 1
d887 1
d889 1
d891 1
d893 1
d951 1
a951 2
    USHORT	add_count;
    USHORT	add_index;
d967 2
a968 2
	sprintk( szMsgBuffer, szNoDriverTab, (PSZ)szDriverName );
	DevHelp_Save_Message( (NPBYTE)&msgBuffer );
d977 1
a977 1
    for( pDCE = pDCT->DCTableEntries, add_index = 0;
d1003 2
a1004 2
		sprintk( szMsgBuffer, szNoDevTab, (PSZ)szDriverName, add_index );
		DevHelp_Save_Message( (NPBYTE)&msgBuffer );
d1012 3
a1014 1
	for( j = 0; j < ((PDEVICETABLE)DeviceTable)->TotalAdapters; ++j )
d1021 1
a1021 1
	    if( CheckAdapterInfo(add_index, npAdapterInfo) )
d1047 1
a1047 1
		if( CheckUnitInfo(add_index, npUnitInfo) )
d1052 3
a1054 3
		    sprintk( szMsgBuffer, szFoundDevice,
			    add_index, npUnitInfo->UnitIndex );
		    DevHelp_Save_Message( (NPBYTE)&msgBuffer );
d1076 2
d1087 3
d1091 2
a1092 2
		    TO_OPTION FAR * p = QueryTOTable( add_index,
						     npUnitInfo->UnitIndex );
d1100 1
a1100 2
		if( InstallFilter(anpUnit[cUnit],
				  add_index, npUnitInfo->UnitIndex) )
d1136 1
a1136 1
	    DevHelp_Save_Message( (NPBYTE)&msgBuffer );
d1170 1
a1170 1
	DevHelp_Save_Message( (NPBYTE)&msgBuffer );
d1283 1
a1283 1
	DevHelp_Save_Message( (NPBYTE)&msgBuffer );
d1291 1
a1291 1
	DevHelp_Save_Message( (NPBYTE)&msgBuffer );
d1300 1
a1300 1
	DevHelp_Save_Message( (NPBYTE)&msgBuffer );
d1309 1
a1309 1
	DevHelp_Save_Message( (NPBYTE)&msgBuffer );
d1342 1
a1342 1
		    DevHelp_Save_Message( (NPBYTE)&msgBuffer );
d1372 1
a1372 1
		    DevHelp_Save_Message( (NPBYTE)&msgBuffer );
d1506 1
a1506 1
	DevHelp_Save_Message( (NPBYTE)&msgBuffer );
d1510 1
a1510 1
	    DevHelp_Save_Message( (NPBYTE)&msgBuffer );
d1515 1
a1515 1
	    DevHelp_Save_Message( (NPBYTE)&msgBuffer );
d1527 1
a1527 1
	DevHelp_Save_Message( (NPBYTE)&msgBuffer );
@


1.4
log
@Better TestOperation(), corrected error display
Displays missing 16MB, HW S/G support (debug)
Parses /[!]UT tokens (timeout per device)
@
text
@d3 2
a4 2
 * $Revision: 1.3 $
 * $Date: 1996/10/24 00:12:25 $
d10 5
d30 1
a30 1
static char vcid[]="$Id: init1.c,v 1.3 1996/10/24 00:12:25 vitus Exp vitus $";
d115 1
a115 1
			"Copyright 1996 by Vitus Jensen (2:2474/400.8)                " __DATE__ ;
@


1.3
log
@Added registration check/display
Modularisiert
Added /Debug[:1] switch
Tests start/stop
@
text
@d2 3
a4 3
 * $Source: e:/source/driver/sleep/init1.c,v $
 * $Revision: 1.2 $
 * $Date: 1996/09/30 00:27:21 $
d10 6
d25 1
a25 1
static char vcid[]="$Id: init1.c,v 1.2 1996/09/30 00:27:21 vitus Exp vitus $";
d67 2
d81 14
a94 2
char _ininit	szStopFailed[]=	"%s: adapter %u, unit %u STOP UNIT failed (%u, %02x %02x %02x)";
char _ininit	szStartFailed[]="%s: adapter %u, unit %u, START UNIT failed (%u, %02x %02x %02x)";
d108 2
a109 1
char _ininit szLogo[]=	"\n\rSCSI Disk Sleeper                                            Version %u.%02u\n\r" \
d131 13
d152 67
d294 1
d296 1
d298 2
d301 2
d304 1
d309 3
a311 1
 *	Assume 32 bytes statusblock to be enough.
d316 7
a322 2
    NPIORB_ADAPTER_PASSTHRU ioadp = (NPVOID)device->iorb;
    NPBYTE const	statusblock = npInitData;
d324 6
d333 13
a345 10
    memset( ioadp, 0, sizeof(IORB_ADAPTER_PASSTHRU) );
    memset( statusblock, 0, 32 );
    ioadp->iorbh.Length =		sizeof(IORB_ADAPTER_PASSTHRU);
    ioadp->iorbh.UnitHandle =		device->hdADDUnit;
    ioadp->iorbh.CommandCode =		IOCC_ADAPTER_PASSTHRU;
    ioadp->iorbh.CommandModifier =	IOCM_EXECUTE_CDB;

    ioadp->iorbh.RequestControl = IORB_REQ_STATUSBLOCK;
    ioadp->iorbh.StatusBlockLen =	32;
    ioadp->iorbh.pStatusBlock =		statusblock;
d347 2
a348 2
    ioadp->pControllerCmd =		device->cdbStop;
    ioadp->ControllerCmdLen =		6;
d350 1
a350 1
    if( (error=SendIORB((PIORB)ioadp, device->pADDEntry)) )
d353 1
a353 2
		(PSZ)szDriverName, aidx, uidx,
		error, *statusblock, *(statusblock+1), *(statusblock+2) );
d355 1
d359 1
d365 13
a377 10
    memset( ioadp, 0, sizeof(IORB_ADAPTER_PASSTHRU) );
    memset( statusblock, 0, 32 );
    ioadp->iorbh.Length =		sizeof(IORB_ADAPTER_PASSTHRU);
    ioadp->iorbh.UnitHandle =		device->hdADDUnit;
    ioadp->iorbh.CommandCode =		IOCC_ADAPTER_PASSTHRU;
    ioadp->iorbh.CommandModifier =	IOCM_EXECUTE_CDB;

    ioadp->iorbh.RequestControl = IORB_REQ_STATUSBLOCK;
    ioadp->iorbh.StatusBlockLen =	32;
    ioadp->iorbh.pStatusBlock =		statusblock;
d379 2
a380 2
    ioadp->pControllerCmd =		device->cdbStart;
    ioadp->ControllerCmdLen =		6;
d382 1
a382 1
    if( SendIORB((PIORB)ioadp, device->pADDEntry) )
d385 1
a385 2
		(PSZ)szDriverName, aidx, uidx,
		error, *statusblock, *(statusblock+1), *(statusblock+2) );
d387 77
a463 1
	return 1;
d467 2
a468 2
    /* Only reason to execute the code below: stopping _and_
     * starting completed successfully. */
d470 2
d490 13
d512 1
a512 2
	    sprintk( szMsgBuffer, szNoSCSI, (PSZ)szDriverName,
		    add_index );
d806 76
d1041 9
d1130 1
d1151 1
a1151 1
    {TOK_ID_DEBUG,	"/Debug", TYPE_0,	{0,  E,  E}};
d1154 1
a1154 1
    {TOK_ID_DEBUG,	"/Debug:", TYPE_D,	{0,  E,  E}};
d1157 7
a1163 1
    {TOK_ID_TIME,	"/T:", TYPE_D,		{0,  E,  E}};
d1186 2
d1213 1
d1300 33
d1335 1
a1335 1
		UCHAR time = *(cp+TOKL_VALUE);
d1337 1
a1337 1
		usSleepSeconds = (USHORT)time * 60U;
d1343 6
d1378 1
a1378 1
    for( c = 0, i = 0, p = RegData.szUser, k = szNoReg;
d1380 1
a1380 1
	++p, ++i, k = (*(k+1) == '\0' ? szNoReg : k+1) )
d1457 1
a1457 1
	sprintk( szMsgBuffer, szLogo, VERSION, SUBVERSION );
@


1.2
log
@Added command line parsing
@
text
@d3 2
a4 2
 * $Revision: 1.1 $
 * $Date: 1996/09/27 02:28:09 $
d10 3
d19 1
a19 1
static char vcid[]="$Id: init1.c,v 1.1 1996/09/27 02:28:09 vitus Exp vitus $";
a65 1
char _ininit	szFoundDevice[]="%s: found adapter %u, unit %u";
d73 3
d82 2
d88 20
a107 2
char _ininit szLogo[]=	"\n\rSCSI Disk Sleeper\t\tVersion %u.%02u\n\r" \
			"Copyright 1996 by Vitus Jensen (2:2474/100.20)";
d165 1
d170 1
a170 1
    iorb->RequestControl = IORB_ASYNC_POST;
d186 117
a308 1
 *	InstallFilter
d310 282
a591 1
 *	InstallFilter(void)
d610 1
a610 1
InstallFilter(void)
d613 1
a613 1
    USHORT	rc = 0;
a618 1

a625 1

d647 1
a647 1
	    PIORB_CONFIGURATION	pIOCF = (PVOID)npInitData;
d651 1
a655 1
	    pIOCF->iorbh.RequestControl =	IORB_ASYNC_POST;
d666 1
a666 1
		 * any adapters/devices). */
d684 2
a685 16
	    if( !((npAdapterInfo->AdapterDevBus & AI_DEVBUS_SCSI_1)
		  ||  (npAdapterInfo->AdapterDevBus & AI_DEVBUS_SCSI_2)
		  ||  (npAdapterInfo->AdapterDevBus & AI_DEVBUS_SCSI_3)) )
	    {
		/* No SCSI devices to expect on non-SCSI bus,
		 * ignore adapter. */

		if( (fDriverFlags & DF_VERBOSE) )
		{
		    sprintk( szMsgBuffer, szNoSCSI, (PSZ)szDriverName,
			    add_index );
		    DevHelp_Save_Message( (NPBYTE)&msgBuffer );
		}
		continue;			/* next adpter */
	    }

a692 3
		USHORT const	utype = npUnitInfo->UnitType;
		USHORT const	uflags = npUnitInfo->UnitFlags;

d710 1
a710 63

		/* If this unit isn't a disk or a disk but a
		 * diskette, skip this unit.  Could be
		 * expanded to allow more device types in the
		 * future.
		 * Removable media mostly stops by itself
		 * and is no so easy to support as it could
		 * be removed anytime. */

		if( utype != UIB_TYPE_DISK )
		{
		    if( (fDriverFlags & DF_VERBOSE) )
		    {
			sprintk( szMsgBuffer, szNoDiskType, (PSZ)szDriverName,
				add_index, npUnitInfo->UnitIndex );
			DevHelp_Save_Message( (NPBYTE)&msgBuffer );
		    }
		    continue;
		}
		if( (uflags & UF_REMOVABLE) )
		{
		    if( (fDriverFlags & DF_VERBOSE) )
		    {
			sprintk( szMsgBuffer, szRemovable, (PSZ)szDriverName,
				add_index, npUnitInfo->UnitIndex );
			DevHelp_Save_Message( (NPBYTE)&msgBuffer );
		    }
		    continue;
		}
		if( (uflags & (UF_A_DRIVE | UF_B_DRIVE)) )
                {
		    if( (fDriverFlags & DF_VERBOSE) )
		    {
			sprintk( szMsgBuffer, szDiskette, (PSZ)szDriverName,
				add_index, npUnitInfo->UnitIndex );
			DevHelp_Save_Message( (NPBYTE)&msgBuffer );
		    }
		    continue;
		}


		/* If this unit is defect or the ADD command
		 * line indicates NO DASD/SCSI support then
		 * skip the unit */

		if( (uflags & UF_DEFECTIVE) )
		{
		    if( (fDriverFlags & DF_VERBOSE) )
		    {
			sprintk( szMsgBuffer, szDefective, (PSZ)szDriverName,
				add_index, npUnitInfo->UnitIndex );
			DevHelp_Save_Message( (NPBYTE)&msgBuffer );
		    }
		    continue;
		}
		if( (uflags & (UF_NODASD_SUPT | UF_NOSCSI_SUPT)) )
		{
		    if( (fDriverFlags & DF_VERBOSE) )
		    {
			sprintk( szMsgBuffer, szNoSupport, (PSZ)szDriverName,
				add_index, npUnitInfo->UnitIndex );
			DevHelp_Save_Message( (NPBYTE)&msgBuffer );
		    }
a711 1
		}
d715 1
a715 1
		    sprintk( szMsgBuffer, szFoundDevice, (PSZ)szDriverName,
d749 2
a750 5
		/* To install our filter we have to change the unit
		 * information of this device.  To change the unit info
		 * of a device we have to allocate it (but don't forget
		 * to deallocate afterwards) */

d752 8
a759 78
		    PIORB_UNIT_CONTROL pIOUC = (PVOID)npInitData;


		    /* Send request to ALLOCATE UNIT */

		    pIOUC->iorbh.Length =	sizeof(IORB_UNIT_CONTROL);
		    pIOUC->iorbh.UnitHandle =	npUnitInfo->UnitHandle;
		    pIOUC->iorbh.CommandCode =	IOCC_UNIT_CONTROL;
		    pIOUC->iorbh.CommandModifier = IOCM_ALLOCATE_UNIT;

		    if( SendIORB((PIORB)pIOUC, pADDEntry) )
		    {
			/* Couldn't allocate unit.  Release
			 * any data allocated and continue with
			 * next device. */

			anpUnit[cUnit] = 0;
			npInitData -= sizeof(DEVICE);	/* free memory */

			sprintk( szMsgBuffer, szAllocFailed, (PSZ)szDriverName,
				add_index, npUnitInfo->UnitIndex );
			DevHelp_Save_Message( (NPBYTE)&msgBuffer );
			continue;
		    }
		}

		{
		    PIORB_UNIT_CONTROL pIOUC = (PVOID)npInitData;


		    /* Send request to CHANGE UNITINFO */

		    pIOUC->iorbh.Length =	sizeof(IORB_UNIT_CONTROL);
		    pIOUC->iorbh.UnitHandle =	npUnitInfo->UnitHandle;
		    pIOUC->iorbh.CommandCode =	IOCC_UNIT_CONTROL;
		    pIOUC->iorbh.CommandModifier = IOCM_CHANGE_UNITINFO;
		    pIOUC->Flags =		0;
		    pIOUC->pUnitInfo =		&anpUnit[cUnit]->modinfo;
		    pIOUC->UnitInfoLen =	sizeof(UNITINFO);

		    if( SendIORB((PIORB)pIOUC, pADDEntry) )
		    {
			/* Couldn't change unit info to
			 * force usage of our filter.
			 * Release any configuration stored
			 * and ignore this unit. */

			anpUnit[cUnit] = 0;
			npInitData -= sizeof(DEVICE);	/* free memory */

			sprintk( szMsgBuffer, szChangeUInfoFailed,
				(PSZ)szDriverName,
				add_index, npUnitInfo->UnitIndex );
			DevHelp_Save_Message( (NPBYTE)&msgBuffer );
		    }
		}

		{
		    PIORB_UNIT_CONTROL pIOUC = (PVOID)npInitData;


		    /* Send request to DEALLOCATE UNIT */

		    pIOUC->iorbh.Length =	sizeof(IORB_UNIT_CONTROL);
		    pIOUC->iorbh.UnitHandle =	npUnitInfo->UnitHandle;
		    pIOUC->iorbh.CommandCode =	IOCC_UNIT_CONTROL;
		    pIOUC->iorbh.CommandModifier = IOCM_DEALLOCATE_UNIT;

		    if( SendIORB((PIORB)pIOUC, pADDEntry) )
		    {
			/* Could deallocte unit.
			 * Bad, display and ignore */

			sprintk( szMsgBuffer, szDeallocFailed,
				(PSZ)szDriverName,
				add_index, npUnitInfo->UnitIndex );
			DevHelp_Save_Message( (NPBYTE)&msgBuffer );
		    }
d767 12
a778 1
    if( rc )					/* errors occurred? */
d780 1
d847 6
d874 2
d934 2
a935 2
	/* REQ_OPT_ERR:
	 *	Required option is missing in command line (probably /A: )
d965 23
d1007 37
d1081 3
d1100 4
d1108 10
d1133 1
a1133 1
	rc = InstallFilter();
@


1.1
log
@Initial revision
@
text
@d2 4
a5 4
 * $Source$
 * $Revision$
 * $Date$
 * $Author$
d9 4
a12 1
 * $Log$
d16 1
a16 1
static char vcid[]="$Id$";
d37 1
d39 1
a39 1
#include <dhcalls.h>
d71 5
d81 1
a81 1
char _ininit szLogo[]=	"\nSCSI Disk Sleeper\t\tVersion %u.%02u\n" \
d148 1
a148 1
    (*addentry)( iorb );
d375 1
a375 1
			    add_index, npUnitInfo->UnitHandle );
d387 1
a387 1
		memset( anpUnit[cUnit], 0, sizeof(*anpUnit[cUnit]) );
d548 147
d730 4
d737 3
d747 1
a747 4

    fDriverFlags |= DF_VERBOSE;


@
